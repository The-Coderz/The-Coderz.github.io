<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>https://The-Coderz.github.io/2017/04/16/%E5%9F%BA%E4%BA%8ETCL%E8%AF%AD%E6%B3%95%E7%9A%84expect%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%84%9A%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="基于TCL语法的expect交互式脚本使用"><a href="#基于TCL语法的expect交互式脚本使用" class="headerlink" title="基于TCL语法的expect交互式脚本使用"></a>基于TCL语法的expect交互式脚本使用</h2><p>​    有些事情是是头疼且重复的，譬如登陆线上服务器存在相同密码验证的跳板机、没有持续交付自动化流程的线上代码编译、构建、部署操作等。今天来说说TCL语法的expect脚本（极其简单），用可用的脚本来注释说明即可：</p>
<h3 id="免密码登陆服务器"><a href="#免密码登陆服务器" class="headerlink" title="免密码登陆服务器"></a>免密码登陆服务器</h3><p>​    <strong><em>密码的当然是要写在脚本里的，或者只输入一次，这不是一个hack脚本…</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/expect -f</div><div class="line"></div><div class="line">proc terminal:password:get &#123;promptString&#125; &#123;		# TCL的子程序定义方式</div><div class="line"></div><div class="line">     # Turn off echoing, but leave newlines on.  That looks better.</div><div class="line">     # Note that the terminal is left in cooked mode, so people can still use backspace</div><div class="line">     exec stty -echo echonl &lt;@stdin</div><div class="line"></div><div class="line">     # Print the prompt</div><div class="line">     puts -nonewline stdout $promptString</div><div class="line">     flush stdout</div><div class="line"></div><div class="line">     # Read that password!  :^)</div><div class="line">     gets stdin password</div><div class="line"></div><div class="line">     # Reset the terminal</div><div class="line">     exec stty echo -echonl &lt;@stdin</div><div class="line"></div><div class="line">     return $password</div><div class="line">&#125;</div><div class="line"></div><div class="line">proc chooseMachine &#123; &#125; &#123;</div><div class="line">    puts &quot;请选择机器\n1) 10.0.0.73 (codecenter-pre default);\n2) 10.0.2.153 (codecenter-prod);\n3) 10.0.2.154 (codecenter-prod);\na) 10.0.0.72 (codecenter-node-pre);\nb) 10.0.2.151 (codecenter-node-prod);\nc) 10.0.2.152 (codecenter-node-prod);&quot;;</div><div class="line">    gets stdin choice;</div><div class="line">    switch $choice &#123;</div><div class="line">        1 &#123;</div><div class="line">            return &quot;10.0.0.73&quot;;</div><div class="line">        &#125;</div><div class="line">        1 &#123;</div><div class="line">            return &quot;10.0.2.153&quot;;</div><div class="line">        &#125;</div><div class="line">        2 &#123;</div><div class="line">            return &quot;10.0.2.154&quot;;</div><div class="line">        &#125;</div><div class="line">        a &#123;</div><div class="line">            return &quot;10.0.0.72&quot;;</div><div class="line">        &#125;</div><div class="line">        b &#123;</div><div class="line">            return &quot;10.0.2.151&quot;;</div><div class="line">        &#125;</div><div class="line">        c &#123;</div><div class="line">            return &quot;10.0.2.152&quot;;</div><div class="line">        &#125;</div><div class="line">        default &#123;</div><div class="line">            return &quot;10.0.0.73&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">proc chooseJumper &#123; IP &#125; &#123;</div><div class="line">    switch $IP &#123;</div><div class="line">        &quot;10.0.0.73&quot; &#123; </div><div class="line">            return &quot;120.27.220.50&quot;;</div><div class="line">        &#125;</div><div class="line">        &quot;10.0.0.72&quot; &#123;</div><div class="line">            return &quot;120.27.220.50&quot;;</div><div class="line">        &#125;</div><div class="line">        default &#123;</div><div class="line">            return &quot;121.43.182.162&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">proc chooseJumperAccount &#123; JUMPER &#125; &#123;</div><div class="line">    switch $JUMPER &#123;</div><div class="line">        &quot;120.27.220.50&quot; &#123;</div><div class="line">            return &quot;root&quot;;</div><div class="line">        &#125;</div><div class="line">        default &#123;</div><div class="line">            return &quot;admin&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">set IP [ chooseMachine ];		# TCL 语法的创建变量 + 子程序调用方式</div><div class="line">set JUMPER [ chooseJumper $IP ];</div><div class="line">set JUMPER_ACCOUNT [ chooseJumperAccount $JUMPER ];</div><div class="line">set PASSWORD [ terminal:password:get &quot;输入密码&quot; ];</div><div class="line">spawn ssh van.yzt@100.69.206.131;			# expect 语法，生成一个子程序用于接着后续的“expect”语句交互</div><div class="line">expect &quot;*password:&quot;;</div><div class="line">send &quot;$PASSWORD\r&quot;;</div><div class="line">expect &quot;*$*&quot;;</div><div class="line">send &quot;sudo su admin\r&quot;;</div><div class="line">expect &quot;*password*&quot;;</div><div class="line">send &quot;$PASSWORD\r&quot;;</div><div class="line">expect &quot;*$*&quot;;</div><div class="line">send &quot;ssh $JUMPER_ACCOUNT@$JUMPER\r&quot;;</div><div class="line">expect &quot;*]*&quot;;</div><div class="line">send &quot;ssh root@$IP\r&quot;;</div><div class="line">set timeout 1;</div><div class="line">expect &#123;</div><div class="line">    &quot;*yes/no&quot; &#123; send &quot;yes\r&quot;;exp_continue; &#125;</div><div class="line">    &quot;*password:&quot; &#123; send &quot;Codecenter123\r&quot;; &#125;</div><div class="line">&#125;</div><div class="line">interact;			# 告知子程序，停留在机器上不结束自己，提供给用户后续的操作</div></pre></td></tr></table></figure>
<p>​    同样的，利用expect，还可以做其他的操作，例如打包源码-&gt;上传代码到服务器-&gt;在服务器上编译、构建、部署等。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker简单使用]]></title>
      <url>https://The-Coderz.github.io/2017/04/16/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a>这篇分享介绍了借助Docker来编译Android源码，Docker可以直接把编译工具链和Ubuntu系统整体打包，保证了编译环境和官方的一致。<br>我用的macOS，之前尝试过编译AOSP，出现各种问题，采用虚拟机的方式也常常编译不过，看到可以用docker的新方式，打算尝试用一下。但是从我实际操作来看，docker在mac上是很慢的，并不比虚拟机快多少，在编译AOSP时也会造成卡死，因为在mac平台上docker是要运行在一个虚拟机上的。在尝试docker编译AOSP失败后，我最终还是用macOS编译了，最终成功烧录到nexus手机上。<br>虽然docker不适合我编译AOSP，但是作为一个操作系统级虚拟化实现方案，还是非常优秀滴。写一个编译器做成一个镜像，放在docker容器里运行还是绰绰有余的，比如《自制编译器》里的<code>cbc编译器</code>, 有人就做了一个镜像上传到<a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">DockerHub</a>上了，这样就避免了需要配置一堆环境依赖的麻烦了。<br>也算是对Docker研究了半天，简单记录下docker的用法吧。</p>
<hr>
<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="为什么说Docker比虚拟机快呢？"><a href="#为什么说Docker比虚拟机快呢？" class="headerlink" title="为什么说Docker比虚拟机快呢？"></a>为什么说Docker比虚拟机快呢？</h3><p>因为Docker容器需要的开销有限。和传统的虚拟化相比，容器运行不需要模拟层和管理层，而是使用操作系统的系统调用接口。这降低了运行单个容器所需的开销，也使得宿主机中可以运行更多容器。<br>但这个是对Host机为Linux而言的，macOS上运行docker容器本质上还是跑在linux虚拟机上的。</p>
<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。<br>简单来说，Docker就是：</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<p>镜像是基于联合文件系统的一种层式的结构，由一系列指令一步一步构建出来，例如：添加一个文件；执行一个名人；打开一个端口。<br>当从一个镜像启动容器时，Docker会在该镜像的最底层加载一个读写文件系统，我们想在Docker中运行的程序就是在这个读写层中执行的。<br>下图是Docker的文件系统层。<br><img src="http://p1.bqimg.com/567571/d31fea71fb692f4d.png" alt="Docker文件系统层"></p>
<p>构建镜像最方便的做法是写一个Dockerfile文件，让docker自带的工具读它，然后生出一个镜像文件来。<br>Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像，之后使用docker build命令基于该Dockerfile中的指令构建一个新的镜像。<br>每条指令都会创建一个新的镜像层并对镜像进行提交。Docker大体上按照如下的流程执行Dockerfile中的指令。</p>
<ul>
<li>Docker从基础镜像运行一个容器。</li>
<li>执行一条指令，对容器做出修改。</li>
<li>执行类似docker commit的操作，提交一个新的镜像层。</li>
<li>Docker再基于刚提交的镜像运行一个新容器。</li>
<li>执行Dockerfile中的下一条指令，直到所有指令都执行完毕。</li>
</ul>
<p>这里给两个简单的例子，可以自己研究下：</p>
<ul>
<li><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a></li>
<li><a href="https://hub.docker.com/r/kylemanna/aosp/" target="_blank" rel="external">aosp</a></li>
</ul>
<hr>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>去<a href="https://www.docker.com/" target="_blank" rel="external">Docker官网</a>下载对应操作系统的安装包后，就可以使用了。<br>打开 Kitematic, 可以在这里下载镜像，dockerhub的形式跟github很像，可以commit、pull等。<br><img src="http://p1.bqimg.com/567571/9d49704a11c5ecad.jpg" alt=""></p>
<p>Docker是基于C/S架构的，它有一个docker程序，既能作为客户端，也可以作为服务端。作为客户端时，docker程序向Docker守护进程发送请求（如请求返回守护进程自身的信息），然后再对返回的请求结果进行处理。</p>
<h3 id="通过docker-info-可以得到的一些信息"><a href="#通过docker-info-可以得到的一些信息" class="headerlink" title="通过docker info 可以得到的一些信息"></a>通过docker info 可以得到的一些信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ docker info      </div><div class="line">Containers: 10</div><div class="line"> Running: 1</div><div class="line"> Paused: 0</div><div class="line"> Stopped: 9</div><div class="line">Images: 7</div><div class="line">Server Version: 1.12.6</div><div class="line">//...</div><div class="line">Registry: https://index.docker.io/v1/</div><div class="line">WARNING: No kernel memory <span class="built_in">limit</span> support</div><div class="line">Insecure Registries:</div><div class="line"> 127.0.0.0/8</div></pre></td></tr></table></figure>
<h3 id="创建交互式容器"><a href="#创建交互式容器" class="headerlink" title="创建交互式容器"></a>创建交互式容器</h3><p>我们告诉Docker执行<code>docker run</code>命令，我们告诉Docker基于<code>ubuntu</code>镜像来创建容器，如果本地没有该镜像的话，Docker会连接官方维护的Docker Hub Registry查找该镜像，下载并保存到本地宿主机中。 <code>-i</code>保证容器中STDIN是开启的，<code>-t</code>告诉Docker为要创建的容器分配一个伪tty终端。这样，新创建的容器才能提供一个交互式shell。最后的<code>/bin/bash</code>告诉Docker在新容器中要运行什么命令。其中<code>--name</code>参数告诉Docker创建一个名为<code>test_container</code>的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker --name test_container run -i -t ubuntu /bin/bash</div><div class="line">//...</div><div class="line">root@12345:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<p>这样，我们就能看到容器内的shell了。容器的id是12345。容器的主机名就是该容器的ID。具体可以通过<code>cat /etc/hosts</code>查看。<br>输入<code>exit</code>,就可以返回宿主机的命令行了。一旦退出容器，<code>/bin/bash</code>命令也就结束了，容器也随之停止运行。但容器是仍然存在的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@12345:/<span class="comment"># exit</span></div></pre></td></tr></table></figure></p>
<p>用<code>docker ps -a</code>命令查看当前系统中容器的列表</p>
<p>Docker容器重新启动的时候，会沿用docker run命令时指定的参数来运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker restart (container name or id)</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h3><p><code>-d</code>参数告诉Docker把容器放到后台运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="容器内部都在干些什么"><a href="#容器内部都在干些什么" class="headerlink" title="容器内部都在干些什么"></a>容器内部都在干些什么</h3><p>用<code>docker logs</code>命令来获取容器的日志。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs (container name or id)</div></pre></td></tr></table></figure></p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker top (container name or id)</div></pre></td></tr></table></figure>
<h3 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h3><p>通过<code>docker exec</code>命令在容器内部额外启动新进程，<br>如下启动了新的后台任务和交互式任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> <span class="_">-d</span> (container name or id) touch /etc/new_config_file</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> -t -i (container name or id) /bin/bash</div></pre></td></tr></table></figure>
<h3 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker stop (container name or id)</div></pre></td></tr></table></figure>
<h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><p><code>--restart</code>标志会检查容器的退出代码，并据此来决定是否重启容器。<br>比如<code>--restart=onfailure:5</code>表示Docker会尝试自动重启该容器，最多重启5次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --restart=always --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="深入容器"><a href="#深入容器" class="headerlink" title="深入容器"></a>深入容器</h3><p><code>docker inspect</code>命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置等。这是一大串json数据，可以用<code>--format</code>标志来选定查看结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo docker inspect --format=<span class="string">'&#123;&#123;.Args&#125;&#125;'</span> (container name or id)</div><div class="line">[run.sh docker]</div></pre></td></tr></table></figure></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm (container name or id)</div></pre></td></tr></table></figure>
<p>一次删除所有容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm `docker ps <span class="_">-a</span> -q`</div></pre></td></tr></table></figure></p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>用<code>docker images</code>得到本地的镜像列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo docker images</div><div class="line">REPOSITORY  TAG     IMAGE ID       CREATED    	SIZE</div><div class="line">ubuntu      latest  104bec311bcd   4 weeks ago  129 MB</div><div class="line">ubuntu      14.04   xxx   		   x weeks ago  xxx MB</div></pre></td></tr></table></figure></p>
<p>镜像保存在仓库中，而仓库在于Registry中，默认的Registry是Docker Hub。<br>每个镜像仓库都可以存放很多镜像（比如ubuntu仓库包含了ubuntu各个版本的镜像）。<br>执行<code>sudo docker pull ubuntu</code>命令来拉取ubuntu仓库中所有内容。<br>每个镜像在列出来时都带有一个标签，用于对组成特定镜像的一些镜像层镜像标记。<br>用如下的方式来指定该仓库的某一镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -ti ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>Docker Hub中有两种类型的仓库：用户仓库和顶层仓库。<br><code>用户名/仓库名</code>这种形式表示用户仓库，是由Docker用户创建的；<br>顶层仓库只包含仓库名部分，由Docker内部人来管理的。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为我只是想用docker来配一个编译aosp的环境，对于Docker的很多高级功能还没有接触，比如利用连接和卷之类的Docker特性来组合并管理运行与Docker中的应用、创建多容器的应用栈等。</p>
<hr>
<p> 相关链接<br><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a><br><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a><br><a href="http://numbbbbb.com/2016/09/26/20160926_%E7%94%A8%20Docker%20%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">用 Docker 快速配置前端开发环境</a><br><a href="https://book.douban.com/subject/26285268/" target="_blank" rel="external">《第一本Docker书》</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在macOS 10.12 上编译 Android 5.1]]></title>
      <url>https://The-Coderz.github.io/2017/04/16/%E5%9C%A8macOS%2010.12%20%E4%B8%8A%E7%BC%96%E8%AF%91%20Android%205.1/</url>
      <content type="html"><![CDATA[<hr>
<p>官方文档虽然也有介绍，但是macOS平台上的编译环境问题还存在很多坑。本文介绍下如何在在macOS 10.12 上编译 Android 5.1源码，导入源码到Android Studio中，把系统烧录到Nexus6手机中。</p>
<hr>
<h2 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h2><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><p>AOSP源码需要一个支持大小写敏感的文件系统，100G是至少要的。<a href="https://source.android.com/source/initializing.html#setting-up-a-mac-os-x-build-environment" target="_blank" rel="external">官网</a>有详细的介绍，这里简单列一下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil create -type SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 40g ~/android.dmg</div></pre></td></tr></table></figure></p>
<p>然后挂载这个分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil attach ~/android.dmg -mountpoint /Volumes/android;</div></pre></td></tr></table></figure></p>
<h3 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h3><p>Android的相关编译只能是使用bash.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chsh -s /bin/bash</div></pre></td></tr></table></figure></p>
<p>重启终端。</p>
<h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><p>1、这里需要两个Xcode，可以用命令切换需要使用的Xcode，会有不同的用处。</p>
<ul>
<li>去AppStore下载最新的Xcode</li>
<li>到<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">这里</a>下载5.1.1的Xcode</li>
</ul>
<p>2、创建一个<code>/Developer/SDK</code>文件夹，从Xcode5.1.1中把<code>MacOSX10.8.sdk</code>从<code>Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/</code>复制到 <code>/Developer/SDK</code>中。<br>3、从<code>Xcode5.1.1.dmg</code>复制Xcode.app 到  <code>/Developer</code>目录中。<br>4、从AppStore下载的最新版Xcode会默认放在<code>/Applications</code>目录中<br>5、给两个版本的Xcode都安装command line tools<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo xcode-select -switch /Developer/Xcode.app</div><div class="line">$ xcode-select --install</div><div class="line">$ sudo xcode-select -switch /Applications/Xcode.app</div><div class="line">$ xcode-select --install</div></pre></td></tr></table></figure></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>编译Android5.1需要jdk1.7，去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html" target="_blank" rel="external">官网</a>下载.<br>如果有切换多个版本的jdk需求的话，可以使用<code>jenv</code>这个工具，参考<a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a></p>
<h3 id="安装其他软件"><a href="#安装其他软件" class="headerlink" title="安装其他软件"></a>安装其他软件</h3><p>1、安装MacPorts，需要去<a href="https://www.macports.org/install.php" target="_blank" rel="external">官网</a>下载对应版本的MacPorts<br>2、配置port命令环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p>
<p>3、下载依赖包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>直接去google官方下载会很慢，这里推荐用<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="external">中科大镜像</a><br>1、首先下载 repo 工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/bin</div><div class="line">$ PATH=~/bin:<span class="variable">$PATH</span></div><div class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line"><span class="comment">## 如果上述 URL 不可访问，可以用下面的：</span></div><div class="line"><span class="comment">## curl https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo &gt; ~/bin/repo</span></div><div class="line">$ chmod a+x ~/bin/repo</div></pre></td></tr></table></figure></p>
<p>2、在之前创建的大小写分区上建立一个工作目录，之后源码下载和编译都在这里进行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir WORKING_DIRECTORY</div><div class="line">$ <span class="built_in">cd</span> WORKING_DIRECTORY</div></pre></td></tr></table></figure></p>
<p>3、初始化仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest</div><div class="line"><span class="comment">## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成下面的：</span></div><div class="line"><span class="comment">## REPO_URL = 'https://gerrit-googlesource.proxy.ustclug.org/git-repo'</span></div></pre></td></tr></table></figure></p>
<p>4、选择某个特定的 Android 版本，具体查看<a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">这里</a>,我选择的是android-5.1.1_r14，build号是LMY48M，等会用这个build号下载对应的驱动包，烧录到nexus真机时会用到。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-5.1.1_r14</div></pre></td></tr></table></figure></p>
<p>5、同步源码树<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo sync</div></pre></td></tr></table></figure></p>
<p>源码下载完后，如果没有同步的需求的话，就可以把<code>.repo</code>目录删掉了，防止编译时磁盘空间不够用。</p>
<h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>烧录到真机时需要用到，默认只是用模拟器的话，可以跳过这步。<br>在<a href="https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。</a><br>下载得到的是三个tgz文件，我们只需依次解压三个文件，得到的是三个shell脚本文件，我们先将其置于源码根目录中。<br>依次执行这3个脚本将在源码根目录中生成一个vendor文件夹。</p>
<hr>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="设置文件描述符限制"><a href="#设置文件描述符限制" class="headerlink" title="设置文件描述符限制"></a>设置文件描述符限制</h3><p>在macOS中，默认限制的同时打开的文件数量很少，不能满足编译过程中的高并发需要，因此需要在shell中运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">ulimit</span> -S -n 1024</div></pre></td></tr></table></figure></p>
<h3 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h3><p>在源码根目录下调用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">source</span> build/envsetup.sh</div></pre></td></tr></table></figure></p>
<h3 id="选择设备"><a href="#选择设备" class="headerlink" title="选择设备"></a>选择设备</h3><p>因为我编译后需要烧录到Nexus6上，所以选择<code>aosp_shamu-userdebug</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lunch aosp_shamu-userdebug</div></pre></td></tr></table></figure></p>
<p>如果不需要烧录到真机上的话，用默认的<code>aosp_arm-eng</code>类型就可以了。</p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>因为本机CPU的内核是8核的，所以开16个线程加快编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make -j16</div></pre></td></tr></table></figure></p>
<p>编译成功后，会有类似下面的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### make completed successfully (30:28:08 (hh:mm:ss)) ####</span></div></pre></td></tr></table></figure></p>
<p>编译成功的结果都在<code>out</code>目录中。<br>如果lunch的是<code>aosp_arm-eng</code>类型，就可以用<code>$ emulator</code>命令刷到模拟器了。</p>
<hr>
<h2 id="源码导入到Android-Studio中"><a href="#源码导入到Android-Studio中" class="headerlink" title="源码导入到Android Studio中"></a>源码导入到Android Studio中</h2><p>为了方便查看源码，可以把代码导入到AS中。目前看来，只能支持Java的跳转，对c++的支持不太好。<br>为了让AS理解代码的符号和源码树的结构，需要用如下命令生成一个<code>android.ipr</code>工程配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mmm development/tools/idegen/</div><div class="line">$ development/tools/idegen/idegen.sh</div></pre></td></tr></table></figure></p>
<p>大约需要十几秒的时间，就能在源码根目录下生成android.ipr和android.iml了。<br>用AS打开android.ipr就能导入整个源码了。<br>如果要支持跳转的话，还需要做些配置，可以看这篇教程：<a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a></p>
<hr>
<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>Nexus6手机在打开USB调试，连接电脑后允许调试这台手机，并且在设置中打开“允许 OEM 解锁”。然后令手机进入recovery模式，在关机下，输入如下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ adb reboot bootloader</div></pre></td></tr></table></figure></p>
<p>执行如下命令刷机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fastboot -w flashall</div></pre></td></tr></table></figure></p>
<p>刷机成功后，手机会自动重启，新鲜出炉的系统终于跑起来了。<br>刷机过程中也出现过变砖的情况，可以试一下<a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">这个教程</a>，亲测有效。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://medium.com/@raminmahmoodi/build-android-5-0-lollipop-on-osx-10-10-yosemite-441bd00ee77a" target="_blank" rel="external">Build Android 5.0 Lollipop on OSX 10.10 Yosemite</a><br><a href="http://blog.bihe0832.com/macOS-AOSP.html" target="_blank" rel="external">http://blog.bihe0832.com/macOS-AOSP.html</a><br><a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a><br><a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a><br><a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">Nexus 6 恢复官方兼救砖</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[xlog接入方案]]></title>
      <url>https://The-Coderz.github.io/2017/04/16/xlog%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/Tencent/mars" target="_blank" rel="external">mars</a> 是微信最近开源的终端基础组件，是一个使用 C++ 编写的基础组件。<br>xlog是其中一个可单独使用的高性能日志模块。<br>本文将简单介绍下xlog的特点，并给出一个自定义的输出到文件的策略。</p>
<hr>
<h2 id="xlog的特点"><a href="#xlog的特点" class="headerlink" title="xlog的特点"></a>xlog的特点</h2><p>使用流式压缩方式对单行日志进行压缩，压缩加密后写进作为 log 中间 buffer的 mmap 中，当 mmap 中的数据到达一定大小后再写进磁盘文件中。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmxsvozhbj20jg08iglr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbmxtm3kajj20kp04caa7.jpg" alt=""></p>
<p>输出到文件的主要实现是在 Appender 模块也是可插拔的，如果对默认的策略不满意可以自己实现一套。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fblriu5wrqj20ci0630sv.jpg" alt=""></p>
<p>xlog还存在一些其他策略：</p>
<ul>
<li>每次启动的时候会清理日志，防止占用太多用户磁盘空间</li>
<li>为了防止 sdcard 被拔掉导致写不了日志，支持设置缓存目录，当 sdcard 插上时会把缓存目录里的日志写入到 sdcard 上</li>
</ul>
<p>从下面的log2file流程图中可以看出xlog是如何利用cahce目录解决插拔sdcard的问题的。<br><code>log2file流程图</code><br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmlojbj7dj210i19648b.jpg" alt=""></p>
<h3 id="上一次没写完的日志，如何重新写到日志中"><a href="#上一次没写完的日志，如何重新写到日志中" class="headerlink" title="上一次没写完的日志，如何重新写到日志中"></a>上一次没写完的日志，如何重新写到日志中</h3><p>在日志模块初始化会执行如下的代码，sg_log_buff为与mmap文件映射的逻辑内存，这里会主动调用Flush，把mmap文件中的数据（即上一次没写到日志文件中的日志）fluse到buffer中，并调用__log2file写到日志文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> mmap_file_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="built_in">snprintf</span>(mmap_file_path, <span class="keyword">sizeof</span>(mmap_file_path), <span class="string">"%s/%s.mmap2"</span>, sg_cache_logdir.empty()?_dir:sg_cache_logdir.c_str(), _nameprefix);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> use_mmap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (OpenMmapFile(mmap_file_path, kBufferBlockLength, sg_mmmap_file))  &#123;</div><div class="line">        sg_log_buff = <span class="keyword">new</span> LogBuffer(sg_mmmap_file.data(), kBufferBlockLength, <span class="literal">true</span>);</div><div class="line">        use_mmap = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    AutoBuffer buffer;</div><div class="line">    sg_log_buff-&gt;Flush(buffer); <span class="comment">// 把mmap文件中日志信息flush到内存中，下面调用__log2file写到文件中。</span></div><div class="line">    <span class="keyword">if</span> (buffer.Ptr()) &#123;</div><div class="line">        __writetips2file(<span class="string">"~~~~~ begin of mmap ~~~~~\n"</span>);</div><div class="line">        __log2file(buffer.Ptr(), buffer.Length());</div><div class="line">        __writetips2file(<span class="string">"~~~~~ end of mmap ~~~~~%s\n"</span>, mark_info);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="修改xlog默认的输出到文件的策略"><a href="#修改xlog默认的输出到文件的策略" class="headerlink" title="修改xlog默认的输出到文件的策略"></a>修改xlog默认的输出到文件的策略</h2><h3 id="xlog默认的策略"><a href="#xlog默认的策略" class="headerlink" title="xlog默认的策略"></a>xlog默认的策略</h3><p>每次启动时会删除过期文件，只保留十天内的日志文件(该值定义在appender.cc中的 kMaxLogAliveTime )，所以给 Xlog 的目录请使用单独目录，防止误删其他文件。目前不会根据文件大小进行清理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __del_timeout_file(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_path) &#123;</div><div class="line">    <span class="keyword">time_t</span> now_time = time(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    boost::filesystem::<span class="function">path <span class="title">path</span><span class="params">(_log_path)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (boost::filesystem::exists(path) &amp;&amp; boost::filesystem::is_directory(path))&#123;</div><div class="line">        boost::filesystem::directory_iterator end_iter;</div><div class="line">        <span class="keyword">for</span> (boost::filesystem::directory_iterator iter(path); iter != end_iter; ++iter) &#123;</div><div class="line">            <span class="keyword">time_t</span> fileModifyTime = boost::filesystem::last_write_time(iter-&gt;path());</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (now_time &gt; fileModifyTime &amp;&amp; now_time - fileModifyTime &gt; kMaxLogAliveTime) &#123;</div><div class="line">                <span class="keyword">if</span> (boost::filesystem::is_regular_file(iter-&gt;status())) &#123;</div><div class="line">                    boost::filesystem::remove(iter-&gt;path());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (boost::filesystem::is_directory(iter-&gt;status())) &#123;</div><div class="line">                    __del_files(iter-&gt;path().<span class="built_in">string</span>());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志文件是按天命名的，每天产生一个日志文件。<br>在<code>__openlogfile</code>、<code>__log2file</code>中会调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __make_logfilename(<span class="keyword">const</span> timeval&amp; _tv, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext, <span class="keyword">char</span>* _filepath, <span class="keyword">unsigned</span> <span class="keyword">int</span> _len) &#123;</div><div class="line">    <span class="keyword">time_t</span> sec = _tv.tv_sec;</div><div class="line">    tm tcur = *localtime((<span class="keyword">const</span> <span class="keyword">time_t</span>*)&amp;sec);</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">char</span> temp [<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">snprintf</span>(temp, <span class="number">64</span>, <span class="string">"_%d%02d%02d"</span>, <span class="number">1900</span> + tcur.tm_year, <span class="number">1</span> + tcur.tm_mon, tcur.tm_mday);</div><div class="line">    logfilepath += temp;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="built_in">strncpy</span>(_filepath, logfilepath.c_str(), _len - <span class="number">1</span>);</div><div class="line">    _filepath[_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如在2017年01月10号的日志会写到LOG_20170110.log文件中，到2017年01月11号时，日志写到LOG_20170111.log，依次类推。过期的日志文件会在日志模块初始化时被清理掉。</p>
<h3 id="改写输出到文件的策略"><a href="#改写输出到文件的策略" class="headerlink" title="改写输出到文件的策略"></a>改写输出到文件的策略</h3><p>xlog输出的文件的逻辑都在<code>appender.cc</code>中实现，可以修改这里的代码实现一套自己的策略。<br>比如想要控制日志文件的大小，即Rotating file based on size的策略。<br>这里的实现方案并不支持cachedir。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __writefile(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        assert(<span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> before_len = ftell(sg_logfile);</div><div class="line">    <span class="keyword">if</span> (before_len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果发生了__roate，需要reopen sg_logfile</span></div><div class="line">    <span class="keyword">if</span>(before_len+_len &gt; sg_max_size)&#123;</div><div class="line">        <span class="keyword">if</span>(!__roate())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> != fwrite(_data, _len, <span class="number">1</span>, sg_logfile)) &#123;</div><div class="line">        <span class="keyword">int</span> err = ferror(sg_logfile);</div><div class="line"></div><div class="line">        __writetips2console(<span class="string">"write file error:%d"</span>, err);</div><div class="line"></div><div class="line"></div><div class="line">        ftruncate(fileno(sg_logfile), before_len);</div><div class="line">        fseek(sg_logfile, <span class="number">0</span>, SEEK_END);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> err_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="built_in">snprintf</span>(err_log, <span class="keyword">sizeof</span>(err_log), <span class="string">"\nwrite file error:%d\n"</span>, err);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> tmp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(tmp);</div><div class="line">        LogBuffer::Write(err_log, strnlen(err_log, <span class="keyword">sizeof</span>(err_log)), tmp, len);</div><div class="line"></div><div class="line">        fwrite(tmp, len, <span class="number">1</span>, sg_logfile);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">NumberToString</span> <span class="params">( T Number )</span></span></div><div class="line">&#123;</div><div class="line">     <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</div><div class="line">     ss &lt;&lt; Number;</div><div class="line">     <span class="keyword">return</span> ss.str();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> __calc_filename(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext,<span class="keyword">unsigned</span> <span class="keyword">int</span> index)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">if</span>(index)&#123;</div><div class="line">        logfilepath += <span class="string">"."</span>;</div><div class="line">        logfilepath += NumberToString(index);</div><div class="line">    &#125;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="keyword">return</span> logfilepath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Rotate files:</span></div><div class="line">    <span class="comment">// log.txt -&gt; log.1.txt</span></div><div class="line">    <span class="comment">// log.1.txt -&gt; log2.txt</span></div><div class="line">    <span class="comment">// log.2.txt -&gt; log3.txt</span></div><div class="line">    <span class="comment">// log.3.txt -&gt; delete</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __roate()&#123;</div><div class="line">    <span class="keyword">if</span>(sg_logfilename.empty() || sg_logdir.empty() || sg_logfileprefix.empty())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(sg_logfile);</div><div class="line">    sg_logfile = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = sg_max_files; i &gt; <span class="number">0</span>; --i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> src = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i<span class="number">-1</span>);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> target = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i);</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">src_path</span><span class="params">(src)</span></span>;</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">target_path</span><span class="params">(target)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(target_path))&#123;</div><div class="line">            boost::filesystem::remove(target_path);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(src_path))&#123;</div><div class="line">            boost::filesystem::rename(src_path,target_path);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//reopen</span></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"wb"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __openlogfile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_dir)&#123;</div><div class="line">    <span class="keyword">if</span> (sg_logdir.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果sg_logfile已经打开了，则直接返回。</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sg_logfile) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sg_current_dir = _log_dir;</div><div class="line">    sg_logfilename = __calc_filename(_log_dir, sg_logfileprefix.c_str(), LOG_EXT,<span class="number">0</span>);</div><div class="line"></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"ab"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span> != sg_logfile;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __log2file(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == _data || <span class="number">0</span> == _len || sg_logdir.empty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	    <span class="function">ScopedLock <span class="title">lock_file</span><span class="params">(sg_mutex_log_file)</span></span>;</div><div class="line">        <span class="keyword">if</span> (__openlogfile(sg_logdir)) &#123;</div><div class="line">            __writefile(_data, _len);</div><div class="line">            <span class="keyword">if</span> (kAppednerAsync == sg_mode) &#123;</div><div class="line">                __closelogfile();</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码详见：<a href="https://github.com/FelixZhang00/xlog-rotating-base-size" target="_blank" rel="external">github</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://dev.qq.com/topic/581c2c46bef1702a2db3ae53" target="_blank" rel="external">http://dev.qq.com/topic/581c2c46bef1702a2db3ae53</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spdlog源码学习]]></title>
      <url>https://The-Coderz.github.io/2017/04/16/spdlog%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/gabime/spdlog" target="_blank" rel="external">spdlog</a>是一个用c++11实现的高性能日志库。<br>接入方便，功能丰富，代码可读性较高。</p>
<hr>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>Very fast - performance is the primary goal </li>
<li>Headers only, just copy and use.</li>
<li>Feature rich  using the excellent <a href="https://github.com/fmtlib/fmt" target="_blank" rel="external">fmt</a> library.</li>
<li>Extremely fast asynchronous mode (optional) - using lockfree queues and other tricks to reach millions of calls/sec.</li>
<li><a href="https://github.com/gabime/spdlog/wiki/3.-Custom-formatting" target="_blank" rel="external">Custom</a> formatting.</li>
<li>Multi/Single threaded loggers.</li>
<li>Various log targets:<ul>
<li>Rotating log files.</li>
<li>Daily log files.</li>
<li>Console logging (colors supported).</li>
<li>syslog.</li>
<li>Windows debugger </li>
<li>Easily extendable with custom log targets  (just implement a single function in the sink interface).</li>
</ul>
</li>
<li>Severity based filtering - threshold levels can be modified in runtime as well as in compile time.</li>
</ul>
<hr>
<h2 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h2><p>spdlog中定义了一系列Sink类，作为实际上把log输出到指定目标的对象，每一个Sink唯一对应一个log的输出目标（如console、文件、db）.<br>每一个logger包含一个sink列表，每当上层调用logger的log方法写日志时，logger就会调用sink列表中的每一个sink的 <code>sink(log_msg)</code> 函数，真正往目标中写日志。</p>
<h3 id="实现Rotating-file写日志"><a href="#实现Rotating-file写日志" class="headerlink" title="实现Rotating file写日志"></a>实现Rotating file写日志</h3><p>当前正在写日志的文件名一直都是log.txt。<br>当log.txt写不下时，把它重命名为log1.txt,再重新打开一个log.txt文件。<br>多个文件循环也依次类推。</p>
<pre><code>// Rotate files:
// log.txt -&gt; log.1.txt
// log.1.txt -&gt; log2.txt
// log.2.txt -&gt; log3.txt
// log.3.txt -&gt; delete
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Rotating file sink based on size</div><div class="line"> */</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Mutex&gt;</div><div class="line"><span class="keyword">class</span> rotating_file_sink : <span class="keyword">public</span> base_sink &lt; Mutex &gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    rotating_file_sink(<span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;base_filename, <span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;extension,</div><div class="line">                       <span class="built_in">std</span>::<span class="keyword">size_t</span> max_size, <span class="built_in">std</span>::<span class="keyword">size_t</span> max_files                       ) :</div><div class="line">    &#123;</div><div class="line">        _file_helper.open(calc_filename(_base_filename, <span class="number">0</span>, _extension));</div><div class="line">        _current_size = _file_helper.size(); <span class="comment">//expensive. called only once</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">void</span> _sink_it(<span class="keyword">const</span> details::log_msg&amp; msg) override</div><div class="line">    &#123;</div><div class="line">        _current_size += msg.formatted.size();</div><div class="line">        <span class="keyword">if</span> (_current_size &gt; _max_size)</div><div class="line">        &#123;</div><div class="line">            _rotate();</div><div class="line">            _current_size = msg.formatted.size();</div><div class="line">        &#125;</div><div class="line">        _file_helper.write(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> filename_t <span class="title">calc_filename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; filename, <span class="built_in">std</span>::<span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; extension)</span></span></div><div class="line">    &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">        <span class="keyword">return</span> w.str();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> _rotate()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">using</span> details::os::filename_to_str;</div><div class="line">        _file_helper.close();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = _max_files; i &gt; <span class="number">0</span>; --i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">filename_t</span> src = calc_filename(_base_filename, i - <span class="number">1</span>, _extension);</div><div class="line">            <span class="keyword">filename_t</span> target = calc_filename(_base_filename, i, _extension);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(target))</div><div class="line">            &#123;</div><div class="line">                details::os::remove(target);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(src) &amp;&amp; details::os::rename(src, target))</div><div class="line">            &#123;</div><div class="line">				<span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        _file_helper.reopen(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">filename_t</span> _base_filename;</div><div class="line">    <span class="keyword">filename_t</span> _extension;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_size;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_files;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _current_size;</div><div class="line">    details::file_helper _file_helper;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="实现异步写日志"><a href="#实现异步写日志" class="headerlink" title="实现异步写日志"></a>实现异步写日志</h3><p>所有异步写日志的请求都会被push到一个固定大小的队列中。<br>有一个工作线程会不停的从队列中pop一条日志消息，并最终写到日志中。</p>
<p>调用方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">async_example</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> q_size = <span class="number">4096</span>; <span class="comment">//queue size must be power of 2</span></div><div class="line">    spdlog::set_async_mode(q_size);</div><div class="line">    <span class="keyword">auto</span> async_file = spd::daily_logger_st(<span class="string">"async_file_logger"</span>, <span class="string">"logs/async_log.txt"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">        async_file-&gt;info(<span class="string">"Async message #&#123;&#125;"</span>, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现：<br>开启一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Async Logger implementation</span></div><div class="line"><span class="comment">// Use an async_sink (queue per logger) to perform the logging in a worker thread</span></div><div class="line"></div><div class="line"><span class="comment">//一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭</span></div><div class="line"><span class="comment">// worker thread</span></div><div class="line"><span class="built_in">std</span>::thread _worker_thread;</div><div class="line">_worker_thread(&amp;async_log_helper::worker_loop, <span class="keyword">this</span>)</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::worker_loop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (_worker_warmup_cb) _worker_warmup_cb();</div><div class="line">        <span class="keyword">auto</span> last_pop = details::os::now();</div><div class="line">        <span class="keyword">auto</span> last_flush = last_pop;</div><div class="line">        <span class="keyword">while</span>(process_next_msg(last_pop, last_flush));</div><div class="line">        <span class="keyword">if</span> (_worker_teardown_cb) _worker_teardown_cb();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Send to the worker thread termination message(level=off)</span></div><div class="line"><span class="comment">// and wait for it to finish gracefully</span></div><div class="line"><span class="keyword">inline</span> spdlog::details::async_log_helper::~async_log_helper()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        push_msg(async_msg(async_msg_type::terminate));</div><div class="line">        _worker_thread.join();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...) <span class="comment">// don't crash in destructor</span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从队列中取消息，如果是写日志的消息，则调用sink写日志。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从队列中取消息，如果是写日志的消息，则调用sink写日志。</span></div><div class="line"><span class="comment">// process next message in the queue</span></div><div class="line"><span class="comment">// return true if this thread should still be active (while no terminate msg was received)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> spdlog::details::async_log_helper::process_next_msg(log_clock::time_point&amp; last_pop, log_clock::time_point&amp; last_flush)</div><div class="line">&#123;</div><div class="line">    async_msg incoming_async_msg;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_q.dequeue(incoming_async_msg))</div><div class="line">    &#123;</div><div class="line">        last_pop = details::os::now();</div><div class="line">        <span class="keyword">switch</span> (incoming_async_msg.msg_type)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">case</span> async_msg_type::flush:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> async_msg_type::terminate:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            _terminate_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            log_msg incoming_log_msg;</div><div class="line">            incoming_async_msg.fill_log_msg(incoming_log_msg);</div><div class="line">            _formatter-&gt;format(incoming_log_msg);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : _sinks)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s-&gt;should_log( incoming_log_msg.level))</div><div class="line">                &#123;</div><div class="line">                    s-&gt;<span class="built_in">log</span>(incoming_log_msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Handle empty queue..</span></div><div class="line">    <span class="comment">// This is the only place where the queue can terminate or flush to avoid losing messages already in the queue</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> now = details::os::now();</div><div class="line">        handle_flush_interval(now, last_flush);</div><div class="line">        sleep_or_yield(now, last_pop);</div><div class="line">        <span class="keyword">return</span> !_terminate_requested;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用写日志，往队列里塞一条写日志消息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::logger::<span class="built_in">log</span>(level::level_enum lvl, <span class="keyword">const</span> T&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!should_log(lvl)) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        details::<span class="function">log_msg <span class="title">log_msg</span><span class="params">(&amp;_name, lvl)</span></span>;</div><div class="line">        log_msg.raw &lt;&lt; msg;</div><div class="line">        _sink_it(log_msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::async_logger::_sink_it(details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        _async_log_helper-&gt;<span class="built_in">log</span>(msg);</div><div class="line">        <span class="keyword">if</span> (_should_flush_on(msg))</div><div class="line">            _async_log_helper-&gt;flush(<span class="literal">false</span>); <span class="comment">// do async flush</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往队列里塞一条日志进去，准备被写</span></div><div class="line"><span class="comment">//Try to push and block until succeeded (if the policy is not to discard when the queue is full)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::<span class="built_in">log</span>(<span class="keyword">const</span> details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    push_msg(async_msg(msg));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::push_msg(details::async_log_helper::async_msg&amp;&amp; new_msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)) &amp;&amp; _overflow_policy != async_overflow_policy::discard_log_msg)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> last_op_time = details::os::now();</div><div class="line">        <span class="keyword">auto</span> now = last_op_time;</div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            now = details::os::now();</div><div class="line">            sleep_or_yield(now, last_op_time);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据时间间隔让线程等待<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// spin, yield or sleep. use the time passed since last message as a hint</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::sleep_or_yield(<span class="keyword">const</span> spdlog::log_clock::time_point&amp; now, <span class="keyword">const</span> spdlog::log_clock::time_point&amp; last_op_time)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::this_thread;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::milliseconds;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::microseconds;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> time_since_op = now - last_op_time;</div><div class="line"></div><div class="line">    <span class="comment">// spin upto 50 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">50</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// yield upto 150 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">100</span>))</div><div class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::this_thread::yield();</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 20 ms upto 200 ms</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= milliseconds(<span class="number">200</span>))</div><div class="line">        <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">20</span>));</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 200 ms</span></div><div class="line">    <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【2017-01-08 cobertura】]]></title>
      <url>https://The-Coderz.github.io/2017/01/08/2017-01-08-cobertura/</url>
      <content type="html"><![CDATA[<h2 id="cobertura"><a href="#cobertura" class="headerlink" title="cobertura"></a>cobertura</h2><h3 id="cobertura-website"><a href="#cobertura-website" class="headerlink" title="cobertura website"></a><a href="http://cobertura.sourceforge.net/" target="_blank" rel="external">cobertura website</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cobertura是一个用于分析Java单测覆盖率的工具，我按照自己maven工程配置，来说下吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>也不知道为什么，反正我官网没有打开过，资料也不多</strong></p>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://www.mojohaus.org/cobertura-maven-plugin/" target="_blank" rel="external">apache maven plugin</a>，这个可以打开😂。</p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;plugin&gt;</div><div class="line">  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;cobertura-maven-plugin&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;$&#123;cobertura.version&#125;&lt;/version&gt;</div><div class="line">  &lt;configuration&gt;</div><div class="line">    &lt;instrumentation&gt;</div><div class="line">      &lt;includes&gt;			// 规定计算哪一部分的单测覆盖率，如DAO的覆盖率没必要计算</div><div class="line">        &lt;include&gt;com/van/service/**/*.class&lt;/include&gt;</div><div class="line">      &lt;/includes&gt;</div><div class="line">    &lt;/instrumentation&gt;</div><div class="line">  &lt;/configuration&gt;</div><div class="line">&lt;/plugin&gt;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 按照上面的pom配置，cobertura只会计算com.van.service.**.*.class的单测覆盖率。同理，还可以配置<excludes>标签来排除不需要计算的类。  </excludes></p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p><code>mvn -B cobertura:cobertura -Dmaven.test.failure.ignore=true</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  执行上述命令，会在对应的targe/sit/cobertura/下生成需要的内容，打开对应的index.html即可以看到单测覆盖率。    </p>
<center><br><img src="/images/2017/01/08/cobertura执行.png" alt="cobertura命令执行"><br><br><img src="/images/2017/01/08/cobertura统计结果.png" alt="cobertura统计结果"><br></center>

<h3 id="值得注意"><a href="#值得注意" class="headerlink" title="值得注意"></a>值得注意</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 值得注意的是，在我自己的测试(mavne:3, cobertura-maven-plugin:5.0.2)和stack overflow上的提问中，都有类似的情况：cobertura的<ignore>标签在maven中似乎没有什么作用，不过有<include>、<exclude>应该也能满足要求。<br><a href="http://stackoverflow.com/questions/25900958/cobertura-exclude-vs-ignore" target="_blank" rel="external">stack overflow - cobertura-exclude-vs-ignore</a></exclude></include></ignore></p>
<center><br><img src="/images/2017/01/08/stackoverflow-cobertura-ignore-vs-exclude.png" alt="cobertura stack overflow ignore vs exclude"><br></center>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python断点调试]]></title>
      <url>https://The-Coderz.github.io/2017/01/08/Python%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>很多项目是用python写构建脚本的，比如微信最近开源的终端跨平台组件 <a href="https://github.com/Tencent/mars" target="_blank" rel="external">Mars</a><br>本文将以mars为例简单介绍下如何用<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm</a>对python进行断点调试。</p>
<hr>
<h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>open整个mars项目，切换合适的python版本，mars需要python2.7版本。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifkuh496j20h81f0q9j.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbifke5anpj20xm0du0xi.jpg" alt=""></p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifnm18q9j20gk04gt94.jpg" alt=""></p>
<h3 id="Debug-it"><a href="#Debug-it" class="headerlink" title="Debug it"></a>Debug it</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifo65ncyj20po0v6wm7.jpg" alt=""></p>
<p>当代码中需要input时，切换到Console窗口输入<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifq7bsxlj20nm0e4jvb.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifqp5rcaj211q0lutf5.jpg" alt=""></p>
<p>用PyCharm调试跟Android Studio一样，毕竟都是一家公司的产品。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Stetho工具介绍]]></title>
      <url>https://The-Coderz.github.io/2017/01/08/Stetho%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">stetho</a>是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是开发者必备的好工具。</p>
<p>主要功能包括：</p>
<ul>
<li>查看App的布局</li>
<li>网络请求抓包</li>
<li>数据库、sp文件查看</li>
<li>自定义dumpapp插件</li>
<li>对于JavaScript的支持</li>
</ul>
<p>无需root，只要能通过adb连接设备，操作方便。</p>
<h2 id="接入方法"><a href="#接入方法" class="headerlink" title="接入方法"></a>接入方法</h2><h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p>因为目前我们的项目中已经集成了okhttp，只需要在build.gradle添加如下两行配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   <span class="comment">//...</span></div><div class="line"></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-js-rhino:1.3.1'</span></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-okhttp3:1.4.2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在Application类中完成初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MyApplicationCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">     Stetho.initializeWithDefaults(mContext);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用功能"><a href="#使用功能" class="headerlink" title="使用功能"></a>使用功能</h2><ol>
<li>adb方式连接到设备</li>
<li>运行debug模式的app</li>
<li>在Chrome浏览器地址栏中输入chrome://inspect</li>
<li>选择需要inspect的应用进程<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbg4wwn5ftj21aw0qo7az.jpg" alt=""></li>
</ol>
<h3 id="查看App的布局"><a href="#查看App的布局" class="headerlink" title="查看App的布局"></a>查看App的布局</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbfhku1ltsj21kw0s5tt8.jpg" alt=""></p>
<h3 id="网络诊断"><a href="#网络诊断" class="headerlink" title="网络诊断"></a>网络诊断</h3><p>给OkHttpClient添加拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .addNetworkInterceptor(<span class="keyword">new</span> StethoInterceptor())</div><div class="line">    .build();</div></pre></td></tr></table></figure></p>
<p>主要功能有包括下载图片的预览，JSON数据查看，网络请求内容和返回内容<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhpn53jjj21kw0rjk3j.jpg" alt=""></p>
<h3 id="数据库、sp文件查看"><a href="#数据库、sp文件查看" class="headerlink" title="数据库、sp文件查看"></a>数据库、sp文件查看</h3><p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfhrmo7blj21kw0rvgx0.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhsqtl35j21kw0rq7fi.jpg" alt=""></p>
<h3 id="自定义dumpapp插件"><a href="#自定义dumpapp插件" class="headerlink" title="自定义dumpapp插件"></a>自定义dumpapp插件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Stetho.initialize(Stetho.newInitializerBuilder(context)</div><div class="line">        .enableDumpapp(<span class="keyword">new</span> DumperPluginsProvider() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Iterable&lt;DumperPlugin&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Stetho.DefaultDumperPluginsBuilder(context)</div><div class="line">                .provide(<span class="keyword">new</span> HelloWorldDumperPlugin())</div><div class="line">                .provide(<span class="keyword">new</span> APODDumperPlugin(context.getContentResolver()))</div><div class="line">                .finish();</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        .enableWebKitInspector(<span class="keyword">new</span> ExtInspectorModulesProvider(context))</div><div class="line">        .build());</div></pre></td></tr></table></figure>
<p>其中HelloWorldDumperPlugin和APODDumperPlugin是自定义的插件，具体内容可以参考<a href="https://github.com/facebook/stetho/tree/master/stetho-sample" target="_blank" rel="external">Stetho提供的sample程序</a><br>运行dumpapp脚本后以达到与app交互通信的效果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ./dumpapp <span class="_">-l</span></div><div class="line">apod</div><div class="line">crash</div><div class="line">files</div><div class="line">hello</div><div class="line">hprof</div><div class="line">prefs</div></pre></td></tr></table></figure></p>
<h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><p>其中dumpapp是一个python脚本，通信的方式使用的是android提供的<a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">smartsocket接口</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--- smartsockets -------------------------------------------------------</div><div class="line">Port <span class="number">5037</span> is used <span class="keyword">for</span> smart sockets which allow a client on the host</div><div class="line">side to request access to a service <span class="keyword">in</span> the host adb daemon or <span class="keyword">in</span> the</div><div class="line">remote (device) daemon.  The service is requested by ascii name,</div><div class="line">preceeded by a <span class="number">4</span> digit hex length.  Upon successful connection an</div><div class="line"><span class="string">"OKAY"</span> response is sent, otherwise a <span class="string">"FAIL"</span> message is returned.  Once</div><div class="line">connected the client is talking to that (remote or local) service.</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "OKAY"</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "FAIL" &lt;hex4&gt; &lt;reason&gt;</div></pre></td></tr></table></figure></p>
<p>使用PyCharm<a href="http://stackoverflow.com/questions/27952331/debugging-with-pycharm-terminal-arguments" target="_blank" rel="external">对Python进行断点调试</a>：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfian208yj21kw0arwia.jpg" alt=""><br>这段脚本的功能就是通过读取<code>/proc/net/unix</code>文件去找app设置的socket<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfid70oipj21gs044t9m.jpg" alt=""></p>
<ol>
<li>扫描android所有提供socket功能的设备，找到steho的devtools_remote</li>
<li>建立与第一步找到的进程socket，然后通过smartsocket进行通信。</li>
<li>设备上的app相当于一个服务器，脚本是客户端对它进行访问</li>
</ol>
<p>后缀为_devtools_remote的socket是android留给chrome的后门。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Note that _devtools_remote is a magic suffix understood by Chrome which //causes the discovery process to begin.</span></div></pre></td></tr></table></figure></p>
<p>详细内容可以看这篇<a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">官方文档</a><br>这篇文档提供的例子是在命令行中输入下面的命令，就能在电脑上看到手机chrome中的内容了：<br><code>adb forward tcp:9222 localabstract:chrome_devtools_remote</code></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfijp8jqfj21320lo0tp.jpg" alt=""></p>
<p>打开的chrome-devtool其实是一个websocket连接。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfipebrd2j21kw069766.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePageList</span><span class="params">(LightHttpResponse response)</span></span></div><div class="line">    <span class="keyword">throws</span> JSONException &#123;</div><div class="line">  <span class="keyword">if</span> (mPageListResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    JSONArray reply = <span class="keyword">new</span> JSONArray();</div><div class="line">    JSONObject page = <span class="keyword">new</span> JSONObject();</div><div class="line">    page.put(<span class="string">"type"</span>, <span class="string">"app"</span>);</div><div class="line">    page.put(<span class="string">"title"</span>, makeTitle());</div><div class="line">    page.put(<span class="string">"id"</span>, PAGE_ID);</div><div class="line">    page.put(<span class="string">"description"</span>, <span class="string">""</span>);</div><div class="line"></div><div class="line">    page.put(<span class="string">"webSocketDebuggerUrl"</span>, <span class="string">"ws://"</span> + mInspectorPath);</div><div class="line">    Uri chromeFrontendUrl = <span class="keyword">new</span> Uri.Builder()</div><div class="line">        .scheme(<span class="string">"http"</span>)</div><div class="line">        .authority(<span class="string">"chrome-devtools-frontend.appspot.com"</span>)</div><div class="line">        .appendEncodedPath(<span class="string">"serve_rev"</span>)</div><div class="line">        .appendEncodedPath(WEBKIT_REV)</div><div class="line">        .appendEncodedPath(<span class="string">"devtools.html"</span>)</div><div class="line">        .appendQueryParameter(<span class="string">"ws"</span>, mInspectorPath)</div><div class="line">        .build();</div><div class="line">    page.put(<span class="string">"devtoolsFrontendUrl"</span>, chromeFrontendUrl.toString());</div><div class="line"></div><div class="line">    reply.put(page);</div><div class="line">    mPageListResponse = LightHttpBody.create(reply.toString(), <span class="string">"application/json"</span>);</div><div class="line">  &#125;</div><div class="line">  setSuccessfulResponse(response, mPageListResponse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在android上的服务端socket写法,<br>详见LocalSocketServer类的listenOnAddress方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listenOnAddress</span><span class="params">(String address)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  mServerSocket = bindToSocket(address);</div><div class="line">  LogUtil.i(<span class="string">"Listening on @"</span> + address);</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!Thread.interrupted()) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// Use previously accepted socket the first time around, otherwise wait to accept another.</span></div><div class="line">      LocalSocket socket = mServerSocket.accept();</div><div class="line"></div><div class="line">      <span class="comment">// Start worker thread</span></div><div class="line">      Thread t = <span class="keyword">new</span> WorkerThread(socket, mSocketHandler);</div><div class="line">      t.setName(</div><div class="line">          WORKER_THREAD_NAME_PREFIX +</div><div class="line">          <span class="string">"-"</span> + mFriendlyName +</div><div class="line">          <span class="string">"-"</span> + mThreadId.incrementAndGet());</div><div class="line">      t.setDaemon(<span class="keyword">true</span>);</div><div class="line">      t.start();</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketException se) &#123;</div><div class="line">      <span class="comment">// ignore exception if interrupting the thread</span></div><div class="line">      <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      LogUtil.w(se, <span class="string">"I/O error"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException ex) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      LogUtil.w(e, <span class="string">"I/O error initialising connection thread"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  LogUtil.i(<span class="string">"Server shutdown on @"</span> + address);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对于JavaScript的支持"><a href="#对于JavaScript的支持" class="headerlink" title="对于JavaScript的支持"></a>对于JavaScript的支持</h3><p>Chrome开发者工具原生支持JavaScript，所以Stetho也提供了JavaScript的支持。<br>通过在console中输入如下代码可以让设备app弹出一个toast<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">importPackage(android.widget);</div><div class="line">importPackage(android.os);</div><div class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">handler.post(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; Toast.makeText(context, <span class="string">"Hello from JavaScript"</span>, Toast.LENGTH_LONG).show() &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfixpdt6hj21kw0rmgv8.jpg" alt=""><br>更多玩法见<a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">Rhino on Stetho
</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">http://facebook.github.io/stetho/</a><br><a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">https://github.com/facebook/stetho/tree/master/stetho-js-rhino</a><br><a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/</a><br><a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/remote-debugging-legacy</a><br><a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【2017-01-05-powermock】]]></title>
      <url>https://The-Coderz.github.io/2017/01/05/2017-01-05-powermock/</url>
      <content type="html"><![CDATA[<h2 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h2><h3 id="PowerMock-github-project"><a href="#PowerMock-github-project" class="headerlink" title="PowerMock github project"></a><a href="https://github.com/powermock/powermock" target="_blank" rel="external">PowerMock github project</a></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PowerMock是一个强大的测试框架，它集成了Mockito、EasyMock等测试框架，在基于这些框架的基础上，利用修改字节码的手段mock静态方法、私有方法、初始化方法，是一种对过去熟悉的测试框架的增强扩张。</p>
<hr>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>引入PowerMock的jar包，需要注意不同版本的jar包依赖的JUnit版本；</li>
<li>建立测试类；</li>
<li>利用PowerMock写单测；</li>
</ol>
<hr>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="被测试接口：UserService"><a href="#被测试接口：UserService" class="headerlink" title="被测试接口：UserService"></a>被测试接口：UserService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.van.service;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 被测试类</div><div class="line"> * Created by Wuha on 2017/1/8.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">thePublicMethod</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="被测试类实现：UserServiceImpl"><a href="#被测试类实现：UserServiceImpl" class="headerlink" title="被测试类实现：UserServiceImpl"></a>被测试类实现：UserServiceImpl</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.van.service.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.van.UserDAO;</div><div class="line"><span class="keyword">import</span> com.van.service.UserService;</div><div class="line"><span class="keyword">import</span> com.van.util.UserUtil;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Wuha on 2017/1/8.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UserDAO userDAO;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Long XXXX_XXX_LONG;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String XXXX_XXXX_STRING;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.XXXX_XXX_LONG = <span class="number">0L</span>;</div><div class="line">        <span class="keyword">this</span>.XXXX_XXXX_STRING = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(Long XXXX_XXX_LONG, String XXXX_XXXX_STRING)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.XXXX_XXX_LONG = XXXX_XXX_LONG;</div><div class="line">        <span class="keyword">this</span>.XXXX_XXXX_STRING = XXXX_XXXX_STRING;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">thePublicMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// some logic</span></div><div class="line"></div><div class="line">        <span class="keyword">this</span>.thePrivateMethod();</div><div class="line"></div><div class="line">        userDAO.getUserById(XXXX_XXX_LONG);</div><div class="line"></div><div class="line">        UserUtil.theStaticMethod();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> XXXX_XXXX_STRING;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thePrivateMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// some logic</span></div><div class="line">        File file = <span class="keyword">new</span> File(XXXX_XXXX_STRING);</div><div class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</div><div class="line">            <span class="comment">// do some thing</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"file.exist() method mock failed."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="被测试类调用的静态方法"><a href="#被测试类调用的静态方法" class="headerlink" title="被测试类调用的静态方法"></a>被测试类调用的静态方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.van.util;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Wuha on 2017/1/8.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserUtil</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">theStaticMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// some logic</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"static method mock failed."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.van;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.van.service.UserService;</div><div class="line"><span class="keyword">import</span> com.van.service.impl.UserServiceImpl;</div><div class="line"><span class="keyword">import</span> com.van.util.UserUtil;</div><div class="line"><span class="keyword">import</span> org.junit.Assert;</div><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</div><div class="line"><span class="keyword">import</span> org.mockito.*;</div><div class="line"><span class="keyword">import</span> org.mockito.invocation.InvocationOnMock;</div><div class="line"><span class="keyword">import</span> org.mockito.stubbing.Answer;</div><div class="line"><span class="keyword">import</span> org.powermock.api.mockito.PowerMockito;</div><div class="line"><span class="keyword">import</span> org.powermock.core.classloader.annotations.PrepareOnlyThisForTest;</div><div class="line"><span class="keyword">import</span> org.powermock.modules.junit4.PowerMockRunner;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by Wuha on 2017/1/8.</div><div class="line"> */</div><div class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)     <span class="comment">// 测试运行于PowerMock测试框架下,加载特定对象、清除MockRepository等</span></div><div class="line"><span class="meta">@PrepareOnlyThisForTest</span>(&#123;UserUtil.class, UserServiceImpl.class&#125;)    <span class="comment">// 该在注解标明了需要用PowerMock字节码增强的类,如:mock静态方法、final域、私有方法等</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPECTED_STRING = <span class="string">"Hello world."</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXPECTED_LONG = -<span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Mock</span>                           <span class="comment">// mock 一个UserDAO类</span></div><div class="line">    <span class="keyword">private</span> UserDAO userDAO;</div><div class="line"></div><div class="line">    <span class="meta">@Mock</span></div><div class="line">    <span class="keyword">private</span> File mockFile;</div><div class="line"></div><div class="line">    <span class="meta">@Spy</span>  <span class="comment">// spy 一个类,这个注解产生的类,如果不去mock方法,那么在运行它的时候,会调用实际的方法,这点和mockObject.thenCallRealMethod()效果一样</span></div><div class="line">    <span class="meta">@InjectMocks</span>    <span class="comment">// 由于UserService利用了@Autowired注解,而没有public的setter方法,该注解可以帮助吧userDAO给set到service中</span></div><div class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl(EXPECTED_LONG, EXPECTED_STRING);</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 对注解的对象进行语义逻辑处理</div><div class="line">         */</div><div class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * mock处理静态类</div><div class="line">         */</div><div class="line">        PowerMockito.mockStatic(UserUtil.class);</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * mock some method</div><div class="line">         */</div><div class="line">        PowerMockito.when(mockFile.exists()).thenReturn(<span class="keyword">true</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * mock一个construct方法</div><div class="line">         */</div><div class="line">        PowerMockito.whenNew(File.class).withArguments(Mockito.anyString()).thenReturn(mockFile);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * mock static method, the private method mock is the same</div><div class="line">         */</div><div class="line">        PowerMockito.doNothing().when(UserUtil.class, <span class="string">"theStaticMethod"</span>);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 对于DO对象,基本上在insert数据库后会填写该DO主键,有时候业务逻辑需要这个主键,</div><div class="line">         * 这时候,可以使用doAnswer来获取mock方法的入参,来设置id</div><div class="line">         *</div><div class="line">         * 注意,这里不能写成</div><div class="line">         * doAnswer(new Answer()&#123;...&#125;).when(mockObject.mockMethod);</div><div class="line">         * 需要改为:</div><div class="line">         *  ||          ||          ||          ||          ||</div><div class="line">         *  VV          VV          VV          VV          VV</div><div class="line">         *  doAnswer(new Answer()&#123;...&#125;).when(mockObject).mockMethod();</div><div class="line">         *  when中的方法必须拿出来,否则会报:mock的方法没有return值</div><div class="line">         */</div><div class="line">        Mockito.doAnswer(<span class="keyword">new</span> Answer() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">                <span class="keyword">for</span> (Object arg : invocation.getArguments()) &#123;</div><div class="line">                    <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> String) &#123;</div><div class="line">                        arg += <span class="string">"something"</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="string">"origin method expect return value : like thenReturn()"</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).when(userDAO).saveUser(Mockito.anyString(), Mockito.anyInt());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testThePublicMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        Assert.assertEquals(EXPECTED_STRING, userService.thePublicMethod());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><center><br><img src="/images/2017/01/08/powermock运行结果.png" alt="PowerMock运行结果"><br></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照代码中的逻辑，如果没被mock，则会抛出异常。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用TraceView工具定位耗时操作]]></title>
      <url>https://The-Coderz.github.io/2017/01/05/2016-12-27-%E9%80%9A%E8%BF%87trace%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">TraceView</a>是DDMS中的工具，可以用来定位Android app中java方法的耗时操作。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-生成trace文件"><a href="#1-生成trace文件" class="headerlink" title="1.生成trace文件"></a>1.生成trace文件</h3><p>Eclipse中生成trace文件的方法：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1fb5lfcb484j20zg0pmtf7.jpg" alt=""></p>
<p><br><br>Android Studio生成trace文件的方法:</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lgu5dsmj21kw0fmgpk.jpg" alt=""></p>
<p>生成的trace文件将显示在Captures窗口</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lx8hffej20a707jmxe.jpg" alt=""><br>直接把trace文件拖到安装了ADT插件的Eclipse就能打开。</p>
<h3 id="2-Timeline-Panel"><a href="#2-Timeline-Panel" class="headerlink" title="2.Timeline Panel"></a>2.Timeline Panel</h3><p>Timeline展示各个线程占用CPU的情况。<br>横轴为从开始到结束trace的CPU时间，右边纵轴表示各个线程，每一横排表示线程占用CPU的情况。这里主要看主线程main</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5lrgshrqj21kw07jtbu.jpg" alt=""></p>
<p>放大后的效果如图，每个method用不同的颜色表示，展示CPU调用该方法到结束调用的时间。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5m32u3j6j21am0bcn0k.jpg" alt=""></p>
<h3 id="3-Profile-Panel"><a href="#3-Profile-Panel" class="headerlink" title="3.Profile Panel"></a>3.Profile Panel</h3><p>Profile Panel展示了方法全名，方法耗时，调用次数，及方法的调用链关系。<br>在这里调用方法称为”parent”,被调方法称为”children”.</p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb5mewco9uj21kw0ngtsb.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《High Performance Android Apps》</p>
<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">https://developer.android.com/studio/profile/traceview.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[simple-mock-api]]></title>
      <url>https://The-Coderz.github.io/2017/01/05/simple-mock-api/</url>
      <content type="html"><![CDATA[<p>项目中有一个Activiy需要轮询多个接口，实时刷新数据。这里很多业务逻辑都需要依赖当前的状态，所以简单写了一个服务端，用于生成一些mock data，并且支持数据实时刷新。</p>
<p>项目地址：<a href="https://github.com/FelixZhang00/simple-mock-api" target="_blank" rel="external">simple-mock-api</a></p>
<p>挂到<a href="https://www.qcloud.com/" target="_blank" rel="external">腾讯云</a>上就可以公网访问了。</p>
<hr>
<h1 id="simple-mock-api"><a href="#simple-mock-api" class="headerlink" title="simple-mock-api"></a>simple-mock-api</h1><p>Use <a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a> make this simple mock api server.</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>checkout this project,and cd</li>
<li>type <code>npm install</code> in terminal to install dependences</li>
<li>run <code>node app.js</code></li>
<li>get result via your configed cgi，like <a href="http://localhost:3000/get_match_players" target="_blank" rel="external">http://localhost:3000/get_match_players</a></li>
</ol>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>You can config </p>
<pre><code>cgi，
default json file,
custom handle the request, modify json response
</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Create a <code>get_match_detail.json</code> file in <code>data</code> folder.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"101"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In <code>config.js</code> config you mock api</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var config = [</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_detail",</div><div class="line">	"filepath":"data/get_match_detail.json",</div><div class="line">	"need_cache":true,</div><div class="line">	"hookfunc":func_get_match_detail</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_players",</div><div class="line">	"filepath":"data/get_match_players.json",</div><div class="line">	"need_cache":false,</div><div class="line">	"hookfunc":func_get_match_players</div><div class="line">&#125;,</div><div class="line"></div><div class="line">];</div></pre></td></tr></table></figure>
<p>You can custom handle the request by define your custom “hookfunc”, like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func_get_match_detail = <span class="function"><span class="keyword">function</span>(<span class="params">defaultObj,req</span>) </span>&#123;</div><div class="line">	<span class="comment">//increase homescore every time</span></div><div class="line">	<span class="keyword">var</span> homescore = <span class="built_in">parseInt</span>(defaultObj.homescore)+<span class="number">1</span>+<span class="string">""</span>;</div><div class="line">	defaultObj.homescore = homescore;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The param <code>defaultObj</code> means the parsed json object you defined in the key “filepath”. </p>
<p>If the key “need_cache” seted true, than your hookfunc can change the defaultObj in the cache forever.</p>
<h3 id="Start-JSON-Server"><a href="#Start-JSON-Server" class="headerlink" title="Start JSON Server"></a>Start JSON Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node app.js</div></pre></td></tr></table></figure>
<p>Now if you go to <a href="http://localhost:3000/get_match_detail" target="_blank" rel="external">http://localhost:3000/get_match_detail</a>, you’ll get</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"102"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>and the homescore’s value changed every time when you go to the same link.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Postman]]></title>
      <url>https://The-Coderz.github.io/2016/12/28/Postman/</url>
      <content type="html"><![CDATA[<h2 id="Postman工具"><a href="#Postman工具" class="headerlink" title="Postman工具"></a>Postman工具</h2><p><strong><a href="https://www.getpostman.com/docs/" target="_blank" rel="external">Docs</a></strong></p>
<h3 id="变量设置"><a href="#变量设置" class="headerlink" title="变量设置"></a>变量设置</h3><center><br><img src="/images/2016/12/28/Postman设置变量1.png" alt=""><br><br><br><img src="/images/2016/12/28/Postman设置变量2.png" alt=""><br><br><img src="/images/2016/12/28/Postman设置变量3.png" alt=""><br></center>


<h3 id="预调用脚本"><a href="#预调用脚本" class="headerlink" title="预调用脚本"></a>预调用脚本</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到随着时间变化的变量，譬如：认证key，在之前简单的变量设置就显得有些不足了。最好就是在调用脚本的时候，能自动按照规则计算出变量的值，并且把变量这只到环境变量中。Postman的Pre-request Script就是很好的解决途径。</p>
<center><br><img src="/images/2016/12/28/Postman-pre-request-script-01.png" alt=""><br></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，在用<code>{ { token } }</code>这样的环境变量形式(和上面提到的一样)，就可以了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jpeg编码学习笔记]]></title>
      <url>https://The-Coderz.github.io/2016/12/28/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。<br>本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。</p>
<p><br><br><br><br><br></p>
<h2 id="JPEG简介"><a href="#JPEG简介" class="headerlink" title="JPEG简介"></a>JPEG简介</h2><p>一张100X100大小的普通图片，如果未经压缩，大概在100<em>100</em>4*8bits=0.3MB左右,这也是图片在内存中占用的内存大小。<br>通常JPEG文件相对于原始图像,能够得到1/8的压缩比，如此高的压缩率是如何做到的呢？</p>
<p>JPEG能够获得如此高的压缩比是因为使用了有损压缩技术，所谓有损压缩，就是把原始数据中不重要的部分去掉，以便可以用更小的体积保存。</p>
<p>JPEG编码是基于两个idea，第一个是基于相邻的像素信息是相近的，即空间冗余性，尽量少记录重复的数据来达到压缩的效果。第二个是基于图像信号的频谱特性，图像包含各种频率，大部分为低频频谱，少部分为高频频谱。可以保留包含图像信息较多的低频频谱，舍去包含图像信息较少的高频频谱。而达到图片质量没有可察觉的损伤，又能达到压缩的效果。这也说明了JPEG是有损编码。</p>
<p><br><br><br><br><br></p>
<h2 id="JPEG的编码过程"><a href="#JPEG的编码过程" class="headerlink" title="JPEG的编码过程"></a>JPEG的编码过程</h2><p>编码流程如下图：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb2c7jxxyaj20eg08d74o.jpg" alt="编码流程示意图"></p>
<p><br><br><br><br><br></p>
<h3 id="1-色彩空间转换"><a href="#1-色彩空间转换" class="headerlink" title="1.色彩空间转换"></a>1.色彩空间转换</h3><p>将RGB色彩空间转换到其他色彩空间，比如<a href="https://en.wikipedia.org/wiki/YUV" target="_blank" rel="external">YUV</a>色彩空间。<br>出现YUV,主要有两个原因，一个是为了让彩色信号兼容黑白电视机，另外一个原因是为了减少传输的带宽。<br>下图为老电视后面的色差接口。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24juusowj206u046q3w.jpg" alt="电视色差接口"><br>YUV中，Y表示亮度，U和V表示色度，总之它是将RGB信号进行了一种处理，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV的格式也很多，不过常见的就是422和420格式。</p>
<p>下图为420格式，每四个Y共用一组UV分量，每个YUV分量和RGB一样都用8位来表示，YUV色彩空间就比RGB色彩空间所需的存储空间少一半，数据就被压缩到了一半。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24kvqketj20aa04n3zt.jpg" alt="Y420"></p>
<p><br><br><br><br><br></p>
<h3 id="2-离散余弦变换DCT"><a href="#2-离散余弦变换DCT" class="headerlink" title="2.离散余弦变换DCT"></a>2.离散余弦变换DCT</h3><p>简单地说，DCT是傅里叶变换的一种，变换后会得到一个系数。<br>有关DCT的详细介绍可以看这个<a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA" target="_blank" rel="external">视频</a>。</p>
<p>在JPEG压缩过程中，经过颜色空间的转换，每一个色值表示成8X8的图像块，下图为一个色彩域取样块，转化为频率域的DCT系数块：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb24n45lgbj20gv03qq3u.jpg" alt="转化为频率域的DCT系数块"></p>
<p>图片经过此步骤会输出一个频率系数矩阵，左上的系数幅度值最大，越往右下，系数的幅度值越小，频率越高。大部分图片信息都在频率域矩阵左上区域，右下几乎不含有图片信息，甚至只含杂波。<br>注意：转换后的DCT系数块矩阵(x,y)处的值并不和转换前的颜色空间矩阵（x,y）处的像素值直接对应。</p>
<p>这一步骤没有压缩作用，它目的是为下一步骤找低频和高频区域，也就是找出留下的区域和舍去的区域。</p>
<p><br><br><br><br><br></p>
<h3 id="3-量化"><a href="#3-量化" class="headerlink" title="3.量化"></a>3.量化</h3><p>此步是将上步求得的DCT系数的简化的过程，利用人眼对高频部分不敏感的特性来舍去高频部分。<br>这里有两张表分别对亮度和色度做量化处理。</p>
<p>标准亮度量化表：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24qq7yq0j20sw0b8t9r.jpg" alt="标准亮度量化表"></p>
<p>标准色度量化表：<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb24rftccuj20sy0b8gmn.jpg" alt="标准色度量化表"></p>
<p>量化表是控制 JPEG 压缩比的关键。<br>DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据是根据人眼对不同频率的敏感程度的差别所积累下的经验制定的。这个步骤除掉了一些高频量, 损失了很多细节. 但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。<br>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。 经过量化处理后, 在高空间频率段, 将出现大量连续的零。</p>
<p>把上面的DCT系数块通过量化后的结果如下图，其中第一个数-26是直流DC部分，它是一块图象样本的平均值，包含了原始8x8图像块中的很多能量，其余的是交流AC部分。<br>计算方法为：频率系数矩阵的数值除以对应量化表位置上的数值，并四舍五入到最近的整数。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24usawejg20ie034t8o.gif" alt="量化过程"></p>
<p>解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频0字段被舍弃。此步为有损运算，会导致图像质量变低。所以说JPEG是有损编码。</p>
<p><br><br><br><br><br></p>
<h3 id="4-zig-zag游程编码"><a href="#4-zig-zag游程编码" class="headerlink" title="4.zig-zag游程编码"></a>4.zig-zag游程编码</h3><p>量化后的数据还可以进行简化，更大程度的去压缩。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb251cuevrj20fe0bq0tg.jpg" alt="zig-zag表"></p>
<p>根据上面的zig-zag表重排数据的过程：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb255f7vvsj208s05mq38.jpg" alt="zig-zag过程"><br>根据ZigZag表的规则对量化后的数据进行重排后的结果中可以看到出现连续的多个0，这样有利于进行游程编码。</p>
<p><br><br><br><br><br></p>
<h3 id="5-范式Huffman编码"><a href="#5-范式Huffman编码" class="headerlink" title="5.范式Huffman编码"></a>5.范式Huffman编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>huffman编码的基本原理是根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。<br>举个例子，比如下面这段数据</p>
<p><code>AABCBABBCDBBDDBAABDBBDABBBBDDEDBD</code></p>
<p>这段数据里面包含了33个字符，每种字符出现的次数统计如下</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>次数</td>
<td>6</td>
<td>15</td>
<td>2</td>
<td>9</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们用我们常见的定长编码，因为有5个文字，可以用3个bit表示，那么这段文字共需要3*33 = 99个bit来保存</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果根据字符出现的概率，使用如下的编码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>100</td>
<td>0</td>
<td>1110</td>
<td>10</td>
<td>1111</td>
<td></td>
</tr>
</tbody>
</table>
<p>那么这段文字共需要3<em>6 + 1</em>15 + 4<em>2 + 2</em>9 + 4*1 = 63bit，压缩比为63%。 是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。<br>哈弗曼编码一般都是使用二叉树来生成的，频率会高的数据对应的树节点的位置越高。这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb25jyerm4j207h0760sr.jpg" alt="哈夫曼树"></p>
<p><br></p>
<h4 id="Huffman编码在JPEG中"><a href="#Huffman编码在JPEG中" class="headerlink" title="Huffman编码在JPEG中"></a>Huffman编码在JPEG中</h4><p>假设在JPEG量化处理后的数据为：<br><code>35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0</code></p>
<p>根据<a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="external">RLE</a>编码(游程编码)规则<br>1、用固定的4位来存储重复的数量，所以最多重复内容可以记录数量为15，超过15次要进行分段处理；<br>2、只将0作为重复的内容，每个数值记录前面有多少重复的0，末尾如果都是0用EOB作为代表；<br>3、此步不包含第一个数值，第一个数为直流系数，此步只处理交流系数。<br>得到处理结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb262lkvzaj21kw048ab4.jpg" alt="RLE编码"><br><br><br><br> </p>
<p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组,JPEG提供了一张标准的码表用于对这些数字编码<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb263fusn6j210w0he768.jpg" alt="标准码表"></p>
<p>举例来说，第3个单元中的“-6”这个数字，在表中的位置是长度为3的那组，所对应的bit码是“001”，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb265nsj1aj21kw065jt8.jpg" alt="BIT编码"><br><br><br><br> </p>
<p>对于括号前面的数字的编码，分成DC编码和AC编码。<br>下表是针对直流(DC)部分即第一个数字的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0~15之间。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1fb26bixac2j20pc0nugmw.jpg" alt=""></p>
<p>对于其余的交流（AC）部分，取值范围在0~255，哈夫曼表如下：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1fb26bvyx0oj20q211e410.jpg" alt=""></p>
<p><br><br><br><br>完整个编码过程如下表，最终的数据使用10个字节保存了原本长度为64字节的数据，JPEG的压缩算法完成。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb268ej9k9j21kw09yn0a.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/" target="_blank" rel="external">http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/</a></li>
<li><a href="http://thecodeway.com/blog/?p=69" target="_blank" rel="external">http://thecodeway.com/blog/?p=69</a></li>
<li><a href="http://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="external">http://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></li>
<li>《数字图像处理编程入门》</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【2016-11-26 Hello World】]]></title>
      <url>https://The-Coderz.github.io/2016/12/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to The Coders! </p>
<p>这是编程者联盟的第一篇博客。我们会在这里不定期地更新一些技术分享。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[代码浏览工具OpenGrok]]></title>
      <url>https://The-Coderz.github.io/2016/12/28/2016-12-25-%E4%BB%A3%E7%A0%81%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7OpenGrok/</url>
      <content type="html"><![CDATA[<p><a href="https://opengrok.github.io/OpenGrok/" target="_blank" rel="external">OpenGrok</a>是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Android在线源码查看网站<a href="http://androidxref.com/" target="_blank" rel="external">androidxref</a>.</p>
<p><br><br><br><br><br></p>
<h2 id="OpenGrok特性"><a href="#OpenGrok特性" class="headerlink" title="OpenGrok特性"></a>OpenGrok特性</h2><p>OpenGrok 提供如下特性：</p>
<ul>
<li><p>1.快速搜索代码的引擎</p>
<p>  搜索全文、定义、符号、文件路径和修改历史</p>
<p>  搜索任意指定子目录（分层搜索）</p>
<p>  增量更新索引文件</p>
</li>
<li><p>2.支持类似 Google 的查询语法，比如 path:Makefile defs:target</p>
<p>  搜索日期范围内修改的文件</p>
<p>  支持使用通配符搜索，如 * 表示多个字符，? 表示单个字符</p>
<p>  在搜索结果中展示匹配行</p>
</li>
<li><p>3.一个 Web 只读版的版本历史查看界面</p>
<p>  文件的修改日志</p>
<p>  文件在两个版本间的 diff</p>
<p>  文件夹的历史记录</p>
</li>
<li><p>4.带语法高亮的交叉引用显示，可以使用 CSS 自定义样式</p>
<p>  可以开发插件支持新的语言和版本控制系统</p>
<p>  已经支持的语言： <a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Languages-and-Formats" target="_blank" rel="external">Supported Languages and Formats</a></p>
<p>  已经支持的版本控制系统：<a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Revision-Control-Systems" target="_blank" rel="external">Supported Revision Control Systems</a></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="在macOS平台搭建OpenGrok"><a href="#在macOS平台搭建OpenGrok" class="headerlink" title="在macOS平台搭建OpenGrok"></a>在macOS平台搭建OpenGrok</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装tomcat</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install tomcat</div></pre></td></tr></table></figure>
<p>2.安装ctags</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install ctags</div></pre></td></tr></table></figure>
<p>3.安装OpenGrok</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -O - http://java.net/projects/opengrok/downloads/download/opengrok-0.12.1.tar.gz | tar xvz</div></pre></td></tr></table></figure>
<h3 id="开启tomcat"><a href="#开启tomcat" class="headerlink" title="开启tomcat"></a>开启tomcat</h3><p>方法1：cd到tomcat所在目录，然后执行命令，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ catalina start </div><div class="line">$ open http://localhost:8080/<span class="built_in">source</span></div></pre></td></tr></table></figure></p>
<p>方法2：下载macOS下的GUI程序<a href="https://www.macupdate.com/app/mac/18706/tomcat-controller" target="_blank" rel="external">TomcatController</a><br>配置tomcat所在目录。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vmdecmpj217c0i6gpb.jpg" alt=""></p>
<h3 id="开启openGrok项目"><a href="#开启openGrok项目" class="headerlink" title="开启openGrok项目"></a>开启openGrok项目</h3><p>openGrok其实就是一个webapp<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vobc954j21kw09saf1.jpg" alt=""></p>
<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>比如导入ffmpeg，在opengrok目录下创建一个local_src文件夹，把ffmpeg文件夹通过软引用的方式链到local_src下的src目录，这样就能让opengrok找到ffmpeg的代码了。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vt7txidj21kw0cx42c.jpg" alt=""></p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vtrtcuwj216g03476a.jpg" alt=""></p>
<h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p>访问 <a href="http://localhost:8080/source" target="_blank" rel="external">http://localhost:8080/source</a> 就能看到代码了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb2vuwcxfej21gc0aw3zw.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vv6s7voj21kw1d3aoa.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/" target="_blank" rel="external">http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24369747</a></p>
<p><a href="https://github.com/OpenGrok/OpenGrok/wiki/Features" target="_blank" rel="external">https://github.com/OpenGrok/OpenGrok/wiki/Features</a></p>
<p><a href="http://bytesthink.com/blog/?p=184" target="_blank" rel="external">http://bytesthink.com/blog/?p=184</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ELF文件装载链接过程及hook原理]]></title>
      <url>https://The-Coderz.github.io/2016/12/28/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="ELF文件格式解析"><a href="#ELF文件格式解析" class="headerlink" title="ELF文件格式解析"></a>ELF文件格式解析</h2><p>可执行和可链接格式(Executable and Linkable Format，缩写为ELF)，常被称为ELF格式，在计算机科学中，是一种用于执行档、目的档、共享库和核心转储的标准文件格式。</p>
<p>ELF文件主要有四种类型：</p>
<ul>
<li>可重定位文件（Relocatable File） 包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</li>
<li>可执行文件（Executable File） 包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。</li>
<li>共享目标文件（Shared Object File） 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。</li>
</ul>
<p>以一个简单的目标文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int global_init_var = 84;</div><div class="line">int global_uninit_var;</div><div class="line">void func1(int i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d\n&quot;,i);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    char *str = &quot;hello&quot;;</div><div class="line">    static int static_var = 85;</div><div class="line">    static int static_var2;</div><div class="line">    int a = 1;</div><div class="line">    int b;</div><div class="line">    func1(static_var + static_var2 + a + b);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c SimpleSection.c</div></pre></td></tr></table></figure>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kqr2mfoj20ty14k76x.jpg" alt="ELF文件结构"></p>
<h3 id="链接视图和执行视图"><a href="#链接视图和执行视图" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>ELF文件在磁盘中和被加载到内存中并不是完全一样的，ELF文件提供了两种视图来反映这两种情况:链接视图和执行视图。顾名思义，链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kvnpkstj20bz06fwf8.jpg" alt="链接视图和执行视图"></p>
<p>程序头部表(Program Header Table)，如果存在的话，告诉系统如何创建进程映像。<br>节区头部表(Section Header Table)包含了描述文件节区的信息，比如大小，偏移等。</p>
<h3 id="ELF文件头（ELF-Header）"><a href="#ELF文件头（ELF-Header）" class="headerlink" title="ELF文件头（ELF Header）"></a>ELF文件头（ELF Header）</h3><p>定义了ELF魔数、硬件平台等、<br>入口地址、程序头入口和长度、<br>段表的位置和长度及段的数量、<br>段表字符串表（.shstrtab）所在的段在段表中的下标。</p>
<p>可以在”/usr/include/elf.h”中找到它的定义（Elf32_Ehdr）。<br>ELF各个字段的说明:</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kwlnz2ej20ht0snqbv.jpg" alt=""></p>
<h3 id="段表-Section-Header-Table"><a href="#段表-Section-Header-Table" class="headerlink" title="段表(Section Header Table)"></a>段表(Section Header Table)</h3><p>描述了各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。<br>段表的结构是一个以Elf32_Shdr结构体（段描述符）为元素的数组。<br>每个Elf32_Shdr结构体对应一个段。<br>使用readelf工具查看ELF文件的段:<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kx9tdv3j21kw0sfak2.jpg" alt=""></p>
<p><strong>段描述符（Elf32_Shdr）</strong>的各个成员及含义：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92kyt2f0gj21kw1oq4j0.jpg" alt=""></p>
<p><strong>段的类型(sh_type)</strong><br>对于编译器和链接器，主要决定段的属性的是段的类型(sh_type)和段的标志位(shflags)。段的类型相关常量以SHT开头，列举如下表。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1f92l0g93grj20k80bg0vq.jpg" alt=""></p>
<p><strong>段的标志位(sh<em>flag)</em></strong>表示该节在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。相关常量以SHF开头，如下表：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1f92l38ufjqj20k504sjsn.jpg" alt=""></p>
<p><strong>段的链接信息(sh_link、sh_info)</strong> 如果节的类型是和链接相关的，比如重定位表、符号表等，那么sh_link和sh_info两个成员包含的意义如下。对于其他段，这两个成员没有意义。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92l3seot7j20kd06babi.jpg" alt=""></p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(.text)"></a>代码段(.text)</h3><p>使用objdump工具查看代码段的内容，”-d”参数将所有包含指令的段反汇编。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l64fa4ej21b41q2114.jpg" alt=""></p>
<h3 id="数据段-data-和只读数据段-rodata"><a href="#数据段-data-和只读数据段-rodata" class="headerlink" title="数据段(.data)和只读数据段(.rodata)"></a>数据段(.data)和只读数据段(.rodata)</h3><p>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面SimpleSection.c代码里面一共有两个这样的变量，都是int类型的，一共刚好8字节。<br>在SimpleSection.c里在调用”printf”的时候，用到了一个字符串常量”%d\n”,它是一种只读数据，所以被放到了”.rodata”段。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l6sfdb3j21ei0kmmzk.jpg" alt=""></p>
<h3 id="BSS段-bss"><a href="#BSS段-bss" class="headerlink" title="BSS段(.bss)"></a>BSS段(.bss)</h3><p>.bss段存放的未初始化的全局变量和局部静态变量。.bss段不占磁盘空间。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92l7ea9guj21eo0ao0ti.jpg" alt=""></p>
<h3 id="字符串表（-strtab）"><a href="#字符串表（-strtab）" class="headerlink" title="字符串表（.strtab）"></a>字符串表（.strtab）</h3><p>在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\0’分隔，然后使用字符串在表中的偏移来引用字符串。<br>比如下面这样：<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l7t2tyrj20k903fgm5.jpg" alt=""><br>那么偏移与他们对用的字符串如下表:<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l81n2y1j20k7043jrs.jpg" alt=""><br>这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存，常见的段名为”.strtab”或”.shstrtab”。这两个字符串表分别为字符串表(String Table)和段表字符串表(Header String Table)，字符串表保存的是普通的字符串，而段表字符串表用来保存段表中用到的字符串，比如段名。</p>
<h3 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（.symtab）</h3><p>在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。<br>每一个目标文件中都有一个相应的符号表(System Table)，这个表里纪录了目标文件所用到的所有符号。每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。<br>符号表是一个Elf32_Sym(32位)的数组，每个Elf32_Sym对应一个符号。这个数组的第一个元素，也就是下标为0的元素为无效的”未定义”符号。<br>他们的定义如下：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l8p5639j20ku06t768.jpg" alt=""></p>
<p><strong>符号类型和绑定信息(st_info)</strong><br>该成员的低4位标识符号的类型(Symbol Type)，高28位标识符号绑定信息(Symbol Binding)，如下表所示。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9hsyp1j20kf04rwf9.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9o0v6dj20k907575x.jpg" alt=""><br><strong>符号所在段(st_shndx)</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在段在段表中的下表，但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊。如下：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92la2n675j20kk07dq4r.jpg" alt=""></p>
<p><strong>符号值(st_value)</strong><br>每个符号都有一个对应的值。主要分下面几种情况：</p>
<ul>
<li>如果符号不是”COMMON”类型的(即st_shndx不为SHN_COMMON)，则st_value表示该符号在段中的偏移，即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。比如SimpleSection中的”func1”，”main”和”global_init_var”。</li>
<li>在目标文件中，如果符号是”COMMON”类型(即st_shndx为SHN_COMMON)，则st_value表示该符号的对齐属性。比如SimleSection中的”global_uninit_var”。</li>
<li>在可执行文件中，st_value表示符号的虚拟地址。</li>
</ul>
<p>下图为使用readelf工具来查看ELF文件的符号:<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lb4pncvj21jm0rgtea.jpg" alt=""><br>比如，Num13行指的是符号表中的第13个元素，符号名为main，它是函数类型，定义在第一个段（即.text段）的第001b偏移处，大小为64字节。</p>
<h3 id="重定位表-rel-text"><a href="#重定位表-rel-text" class="headerlink" title="重定位表(.rel.text)"></a>重定位表(.rel.text)</h3><p>SimpleSection.o中有一个叫”.rel.text”的段，它的类型(sh_type)为”SHT_REL”，也就是说它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据中中那些绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如”.rel.text”就是针对”.text”的重定位表，”.rel.data”就是针对”.data”的重定位表。</p>
<hr>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>这节以下面两个文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* a.c */</div><div class="line">extern int shared;</div><div class="line">int main()&#123;</div><div class="line">    int a = 100;</div><div class="line">    swap(&amp;a,&amp;shared);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* b.c */</div><div class="line">int shared = 1;</div><div class="line">void swap(int* a, int* b)&#123;</div><div class="line">    *a ^= *b ^= *a ^= *b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？<br>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？输出文件中的空间如何更配给输入文件？<br>下图为现在链接器采用的空间分配策略。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lhyc2ugj2124138dkb.jpg" alt=""></p>
<p>整个链接过程分两步：</p>
<ul>
<li>第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表中。</li>
<li>第二步 符号解析与重定位 使用第一步中收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等</li>
</ul>
<p>使用ld链接器将”a.o”和”b.o”链接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ld a.o b.o -e main -o ab</div></pre></td></tr></table></figure></p>
<p>查看链接前后各个段的属性<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ljdpqkgj21b418244f.jpg" alt=""><br>VMA表示虚拟地址，LMA表示加载地址，正常情况下这两个值应该一样。</p>
<p>整个链接过程前后，目标文件各段的分配、程序虚拟地址:<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92ljxvmqmj21hq10ygo3.jpg" alt=""><br>在Linux下，ELF可执行未见默认从地址0x08048000开始分配。</p>
<h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><p>编译器在将”a.c”编译成指令时，它如何访问”shared”变量？如何调用”swap”函数？<br><strong>重定位表(Relocation Tabel)</strong>专门用来保存与重定位相关的信息，链接器根据它知道哪些指令时要被调整的，以及如何调整。<br>对于32位的Intel x86系列处理器来说，重定位表的结构是一个Elf_32Rel结构的数组，每个数组元素对应一个重定位入口。定义如下：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lm64qwqj21j00kwtec.jpg" alt=""></p>
<p>可以使用objdump来查看目标文件的重定位表：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lmerm9rj20oa0bu3za.jpg" alt=""></p>
<p>将”a.o”的代码段反汇编可以看到，此时编译器并不知道“shared”的地址，暂时把地址0看做”shared”的地址。<br>0xE8是一条近址相对位移调用指令，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。<br>此处”swap”函数的地址是0x2b-4=0x27,可以看出0xfffffffc也是一个临时地址。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lmrq7o2j21900yagpl.jpg" alt=""></p>
<p><strong>指令修正方式</strong><br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lngo4gzj21iu0fsjuq.jpg" alt=""></p>
<p>指令修复的结果<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lnnaqsej21d411ydlb.jpg" alt=""></p>
<hr>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>程序执行时所需要的指令和数据必需在内存中才能够正常运行。<br>页映射将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p>
<p>进程的建立需要做下面三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li>
</ul>
<p>对于第2步，当操作系统捕获到缺页错误时，它应该知道程序当前所需的页在可执行文件中的哪一个位置。<br>这种映射关系是保存在操作系统内部的一个数据结构<strong>VMA</strong>。<br>例如下图中，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读，还有一些其他的属性。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lokbzk3j20wi0lo0u7.jpg" alt=""></p>
<p><strong>页错误</strong><br>在上面的例子中，程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000（虚拟地址）是个空页面，于是它就认为这是一个页错误。CPU将控制权交给操作系统，操作系统将查询虚拟空间与可执行文件的映射关系表，找到空页面所在的VMA，计算相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。</p>
<h3 id="链接视图和执行视图-1"><a href="#链接视图和执行视图-1" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>以下面的程序为例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">使用静态链接的方式将其编译成可执行文件：</div><div class="line">$gcc -static SectionMapping.c -o SectionMapping.elf</div><div class="line">**/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的elf文件被重新划分成了三个部分，有一些段被归入可读可执行的，他们被统一映射到一个CODE VMA；另一部分段是可读可写的，它们被映射到了DATA VMA；还有一些段在程序执行时没有用，所以不需要映射。<br>ELF与Linux进程虚拟空间映射关系（一个常见进程的虚拟空间）如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lpqlsm9j212y1fkaem.jpg" alt=""></p>
<h4 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h4><p>用来保存“Segment”的信息,描述了ELF文件该如何被操作系统映射到虚拟空间。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有。<br>使用readelf查看程序头表。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lreiga6j21380me0x3.jpg" alt=""></p>
<p>跟段表结构一样，程序头表也是一个结构体数组，其结构体用Elf32_Phdr表示。<br>下表是Elf32_Phdr结构的各个成员的基本含义。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lrncz74j21jw0vwgtx.jpg" alt=""></p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>VMA除了被用来映射可执行文件中的各个”segment”以外，操作系统通过使用VMA来对进程的地址空间进行管理，包括堆和栈。<br>在Linux下，可以通过查看”/proc”来查看进程的虚拟空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ltj5czaj21120hkwi3.jpg" alt=""><br>我们可以看到进程中有5个VMA,只有前两个是映射到可执行文件中的两个Segment。另外三个段的文件所在设备主设备号及文件节点号都是0，则表示他们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。另外有一个很特殊的VMA叫“vdso”，它的地址已经位于内核空间了（即大于0xC0000000的地址），事实上它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信。<br>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。</p>
<hr>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>以下面的代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/* Lib.h */</div><div class="line">#ifndef LIB_H</div><div class="line">#define LIB_H</div><div class="line">void foobar(int i);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* Lib.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void foobar(int i)&#123;</div><div class="line">    printf(&quot;Printing from Lib.so %d\n&quot;,i);</div><div class="line">    sleep(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program1.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(1);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program2.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(2);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将Lib.c编译成一个共享对象文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> <span class="_">-f</span>PIC -shared -o Lib.so Lib.c</div></pre></td></tr></table></figure>
<p>分别编译链接Program1.c和Program2.c：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program1 Program1.c ./Lib.so</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program2 Program2.c ./Lib.so</div></pre></td></tr></table></figure>
<p>查看进程的虚拟地址空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lywp140j20zm0n0grl.jpg" alt=""><br>上图中的ld-2.6.so实际上是Linux下的动态链接器，它与普通共享对象一样被映射到了进程的地址空间，在系统开始运行program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给program1,然后开始执行。</p>
<p>通过readelf查看Lib.so的装载属性：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9320c9v7lj214q0q8776.jpg" alt=""><br>与普通程序不同的是，动态链接模块的装载地址是从地址0x00000000开始的，这个地址是无效的，共享对象的最终装载地址在编译时时不确定的，而是在装载时，装载器根据当前地址空间的空前情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p>
<h3 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码(PIC)"></a>地址无关代码(PIC)</h3><p>装载时重定位是解决动态模块中有绝对地址引用的方法之一，但是它有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本思想就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>模块中各种类型的地址引用方式如下图：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9321f0xmjj20hg0go76x.jpg" alt=""></p>
<h4 id="全局偏移表-GOT"><a href="#全局偏移表-GOT" class="headerlink" title="全局偏移表(GOT)"></a>全局偏移表(GOT)</h4><p>用于模块间数据访问，在数据段里建立一个指向外部模块变量的指针数组。当代码需要引用该全局变量时，可以通过GOT中相对用的项间接引用，它的基本机制如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9321to16sj214w10qwgd.jpg" alt=""><br>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h4 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h4><p>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转。程序开始执行时，动态链接器都要进行一次链接工作，会寻找并装载所需的共享对象，然后进行符号查找地址重定位等工作，如此一来，程序的运行速度必定会减慢。</p>
<p>延迟绑定的实现<br>函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。</p>
<p>GOT 位于 .got.plt section 中，而 PLT 位于 .plt section中。<br>GOT 保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到 GOT 中，第二次调用时就直接找到 GOT 表项所存储的函数地址直接调用了。<br>printf（）函数的调用过程如下图<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9322tt0r1j20le0dhjss.jpg" alt=""></p>
<h3 id="动态链接的相关结构"><a href="#动态链接的相关结构" class="headerlink" title="动态链接的相关结构"></a>动态链接的相关结构</h3><h4 id="interp段"><a href="#interp段" class="headerlink" title=".interp段"></a>.interp段</h4><p>在动态链接的ELF可执行文件中，有一个专门的段叫做”.interp”段。里面保存的是一个字符串，记录所需动态链接器的路径。<br>从下图可以看出，Android用的动态链接器是linker<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9323mnszoj21j805itco.jpg" alt=""></p>
<h4 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h4><p>这个段里保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<br>.dynamic段里保存的信息有点像ELF文件头。<br>.dynamic段的结构是由Elf32_Dyn组成的数组。<br>Elf32_Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f932414wnzj21ii0syq9p.jpg" alt=""></p>
<h4 id="动态符号表-dynsym"><a href="#动态符号表-dynsym" class="headerlink" title="动态符号表(.dynsym)"></a>动态符号表(.dynsym)</h4><p>为了表示动态链接模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。<br>与”.symtab”不同的是，”.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接模块同时拥有”.dynsym”和”.symtab”两个表，”.symtab”中往往保存了所有符号，包括”.dynsym”中的符号。</p>
<h4 id="动态符号字符串表-dynstr"><a href="#动态符号字符串表-dynstr" class="headerlink" title="动态符号字符串表(.dynstr)"></a>动态符号字符串表(.dynstr)</h4><p>在动态链接时用于保存符号名的字符串表。</p>
<h4 id="符号哈希表-hash"><a href="#符号哈希表-hash" class="headerlink" title="符号哈希表(.hash)"></a>符号哈希表(.hash)</h4><p>由于动态链接下，需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号好戏表。<br>用readelf查看elf文件的动态符号表及它的哈希表。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9324ovvklj211g0n6af4.jpg" alt=""></p>
<h3 id="动态链接重定位表"><a href="#动态链接重定位表" class="headerlink" title="动态链接重定位表"></a>动态链接重定位表</h3><p>在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>“.rel.dyn”段对数据引用的修正，它所修正的位置位于”.got”以及数据段；<br>“.rel.plt”段对函数引用修正，它所修正的位置位于”.got.plt”。<br>用readelf来查看一个动态链接的文件的重定位表：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f93258e2hrj21i00ue7a1.jpg" alt=""><br>R_386_JUMP_SLOT和R_386_GLOB_DAT这两个类型的重定位入口表示，被修正的位置只需要直接填入符号地址即可。<br>比如，printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8，它位于”.got.plt”中，下图为其结构。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9325hfyr7j213q0zitfq.jpg" alt=""><br>当链接器需要进行重定位时，它先查找”printf”的地址，“printf”位于libc.so中。假设链接器在全局符号表里面找到”printf”的地址为0x08801234,那么链接器就会将这个地址填入到”.got.plt”中偏移为0x000015d8的位置中去，从而实现了地址的重定位。<br>R_386_GLOB_DAT是对”.got”的重定位，它跟R_386_JUMP_SLOT的做法一样。</p>
<hr>
<h2 id="hook方案的一种实现方案"><a href="#hook方案的一种实现方案" class="headerlink" title="hook方案的一种实现方案"></a>hook方案的一种实现方案</h2><p>具体实现来自Andrey Petrov的<a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">blog</a>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &quot;linker.h&quot;  // get it from bionic</div><div class="line">static unsigned elfhash(const char *_name)  </div><div class="line">&#123;  </div><div class="line">  const unsigned char *name = (const unsigned char *) _name;  </div><div class="line">  unsigned h = 0, g;  </div><div class="line">  while(*name) &#123;  </div><div class="line">    h = (h &lt;&lt; 4) + *name++;  </div><div class="line">    g = h &amp; 0xf0000000;  </div><div class="line">    h ^= g;  </div><div class="line">    h ^= g &gt;&gt; 24;  </div><div class="line">  &#125;  </div><div class="line">  return h;  </div><div class="line">&#125;  </div><div class="line">static Elf32_Sym *soinfo_elf_lookup(soinfo *si, unsigned hash, const char *name)  </div><div class="line">&#123;  </div><div class="line">  Elf32_Sym *s;  </div><div class="line">  Elf32_Sym *symtab = si-&gt;symtab;  </div><div class="line">  const char *strtab = si-&gt;strtab;  </div><div class="line">  unsigned n;  </div><div class="line">  n = hash % si-&gt;nbucket;  </div><div class="line">  for(n = si-&gt;bucket[hash % si-&gt;nbucket]; n != 0; n = si-&gt;chain[n])&#123;  </div><div class="line">    s = symtab + n;  </div><div class="line">    if(strcmp(strtab + s-&gt;st_name, name)) continue;  </div><div class="line">      return s;  </div><div class="line">    &#125;  </div><div class="line">  return NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int hook_call(char *soname, char *symbol, unsigned newval) &#123;  </div><div class="line"> soinfo *si = NULL;  </div><div class="line"> Elf32_Rel *rel = NULL;  </div><div class="line"> Elf32_Sym *s = NULL;   </div><div class="line"> unsigned int sym_offset = 0;  </div><div class="line"> if (!soname || !symbol || !newval)  </div><div class="line">    return 0;  </div><div class="line"> si = (soinfo*) dlopen(soname, 0);  </div><div class="line"> if (!si)  </div><div class="line">  return 0;  </div><div class="line"> s = soinfo_elf_lookup(si, elfhash(symbol), symbol);  </div><div class="line"> if (!s)  </div><div class="line">   return 0;  </div><div class="line"> sym_offset = s - si-&gt;symtab;  </div><div class="line"> rel = si-&gt;plt_rel;  </div><div class="line"> /* walk through reloc table, find symbol index matching one we&apos;ve got */  </div><div class="line"> for (int i = 0; i &lt; si-&gt;plt_rel_count; i++, rel++) &#123;  </div><div class="line">  unsigned type = ELF32_R_TYPE(rel-&gt;r_info);  </div><div class="line">  unsigned sym = ELF32_R_SYM(rel-&gt;r_info);  </div><div class="line">  unsigned reloc = (unsigned)(rel-&gt;r_offset + si-&gt;base);  </div><div class="line">  unsigned oldval = 0;  </div><div class="line">  if (sym_offset == sym) &#123;  </div><div class="line">   switch(type) &#123;  </div><div class="line">     case R_ARM_JUMP_SLOT:  </div><div class="line">        /* we do not have to read original value, but it would be good   </div><div class="line">          idea to make sure it contains what we are looking for */  </div><div class="line">        oldval = *(unsigned*) reloc;  </div><div class="line">        *((unsigned*)reloc) = newval;  </div><div class="line">        return 1;  </div><div class="line">     default:  </div><div class="line">        return 0;  </div><div class="line">   &#125;  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line"> return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libandroid_runtime.so&quot;, &quot;connect&quot;, &amp;my_connect);</div></pre></td></tr></table></figure></p>
<p>1.调用dlopen拿到so的句柄,得到soinfo,它包含了符号表、重定位表、plt表等信息。<br>2.查找需要hook的函数的符号，得到它在符号表中的索引。具体实现是soinfo_elf_lookup函数。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f932uud83bj207r088mxj.jpg" alt=""></p>
<p>bucket数组包含nbucket个项目，chain数组包含nchain个项目，下标都是从0开始。bucket和chain中都保存了符号表的索引。chain表项和符号表存在对应。符号表项的数目应该和nchain相等，所以符号表的索引也可以用来选取chain表项。哈希函数能够接受符号名并返回一个可以用来计算bucket的索引。如果哈希函数针对某个名字返回了数值x，则bucket[x%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表。如果该符号表项不是所需要的，那么chain[y]则给出了具有相同哈希值的下一个符号表项。我们可以沿着chain链一直搜索，直到所选中的符号表项包含了所需要的符号，或者chain项中包含值STN_UNDEF。</p>
<p> 3.遍历plt表，直到匹配第2步中找到的符号索引。<br> 如果是JUMP_SLOT类型（函数调用），替换为新的符号地址（函数指针）。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《程序员的自我修养》</li>
<li>《深入理解计算机系统》</li>
<li><a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">Andrey Petrov’s blog</a></li>
<li><a href="https://www.apriorit.com/dev-blog/181-elf-hook" target="_blank" rel="external">Redirecting functions in shared ELF libraries</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【2016-12-02 Java编码小结】]]></title>
      <url>https://The-Coderz.github.io/2016/12/03/2016-12-02-Java%E7%BC%96%E7%A0%81%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编码问题一直都是令程序员捉摸不透的东西，因为它被越来越透明化：程序中默认用OS的字符集、许多文件开头都有编码格式的约定……这就导致一旦遇到乱码的现象，就让人无从下手，所以在了解了一部分知识和实现之后，我想对Java的编码做一下小结，方便日后自己查阅。</p>
<hr>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li>编码：首先，“编码”一词通常是作为动词，即<strong>把一种符号序列通过某种规约转化为另一种符号序列，且语义保持一致</strong>（我自己定义的）；</li>
<li>解码：编码的反向过程；</li>
<li>二进制：在计算机中，信息的表示最小单位为位，由0或1组成，这一特性是通过电信号的有无来决定的；</li>
<li>字节：计算机存储信息的最小单位，一个字节(Byte)=8位(bit)；</li>
<li>字符：这是带有人类能读懂语义的最小单位，如:A,我；</li>
<li>字符集：用来将“字节解码为字符”或“字符编码为字节”的人类规约，有多种规约，如：ANSI、GBK、UTF-8、UTF-16、iso-8859-1等；  </li>
</ul>
<hr>
<h3 id="Java编码"><a href="#Java编码" class="headerlink" title="Java编码"></a>Java编码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个标题起得好像有些奇怪，因为它歧义特别多，由于本文是按照我的思路来写的，也就勉为其难地跟着我的学习思路走吧 ：）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先，很多人（比如我）就会遇到第一个混淆的概念：Java编码=&gt;指的是Java的什么编码：  </p>
<ol>
<li>Java编译：在没有指定编译时的编码时，Java采用Unicode编码。这意味着，Java编译器会将当前代码的编码转换为Unicode统一编码，这样，在不同环境下，.class文件都能正确地输出文件内容；  </li>
<li>JVM的编码格式：在没有指定JVM的编码格式时，Java程序将会用OS的默认编码；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当对这两点有所区分之后，我们就可以细细考究某一个代码片段造成的乱码问题了。但是请稍等，我们再来说说Java中的char和Byte吧？  </p>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们要了解，存储在磁盘上的内容都是经过编码后的内容，此时就要我们明确以某种方式读取（解码）为char类型。其实说到底，字符类型（char）无非就是对字节类型（byte）的某种组合。由于二进制（bit）到字节（byte），其实只是磁盘文件到内存的直接映射（这个直接映射表示没有什么改变，而不是物理存储上的某种关系），所以不需要做什么编码的操作。但是从字节（byte）到字符（char），就需要做编码的操作，来确定谋者映射关系，从而打印到屏幕上能被人类所理解（这不就是最终目标吗）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先，我们知道Java是一门OOP语言，它对动作的封装其实挺全面的，不过正是因为它的透明性，导致我对期间的编码一知半解，所以，了解它的结构，还是很有必要的。char类型的实体在Java中占有<strong>两个字节大小，用来表示Unicode解码后的字符</strong>，下面我们来对应比下C++和Java中字符和字节的表示类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型或操作</th>
<th style="text-align:center">C++</th>
<th style="text-align:center">Java</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字节</td>
<td style="text-align:center">char</td>
<td style="text-align:center">byte</td>
</tr>
<tr>
<td style="text-align:left">字符</td>
<td style="text-align:center">wchar_t</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:left">ANSI字符串</td>
<td style="text-align:center">char[]</td>
<td style="text-align:center">byte[]</td>
</tr>
<tr>
<td style="text-align:left">Unicode字符串</td>
<td style="text-align:center">wchar_t[]</td>
<td style="text-align:center">String</td>
</tr>
<tr>
<td style="text-align:left">字符串=&gt;字节串</td>
<td style="text-align:center">wcstombs(), WideCharToMultiByte()</td>
<td style="text-align:center">String.getBytes(encoding)</td>
</tr>
<tr>
<td style="text-align:left">字节串=&gt;字符串</td>
<td style="text-align:center">mbstowcs(), MultiByteToWideChar()</td>
<td style="text-align:center">new String(bytes,encoding)</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要注意c/c++的char类型和Java中char类型的区别，不要“一视同仁”。</p>
<p><img src="/images/2016/12/04/001.png" alt="Java IO读"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从这张UML图中，我们了解到，Java通过InputStreamReader类这个桥梁，来实现字节到字符的转换，即解码的过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">InputStream fileByteInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"/xx/xx/xx.txt"</span>);</div><div class="line">InputStreamReader fileInputStreamReader = <span class="keyword">new</span> InputStreamReader(fileByteInputStream, <span class="string">"GBK"</span>);  <span class="comment">// 以GBK的方式解码二进制流</span></div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(fileInputStreamReader);</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同理，Java IO中的写也有char到byte的桥梁:  </p>
<p><img src="/images/2016/12/04/002.png" alt="Java IO写">  </p>
<h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String对象被叫做字符串对象，其内部是存储了一个char[]数组，这意味着，这些字符都是经过特定解码的：  </p>
<pre><code class="Java">String s = <span class="keyword">new</span> String(<span class="string">"你"</span>.getBytes(<span class="string">"GBK"</span>), <span class="string">"GBK"</span>);
String a = <span class="keyword">new</span> String(<span class="string">"你"</span>.getBytes(<span class="string">"UTF-8"</span>));
System.out.println(s);
System.out.println(a);
</code></pre>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从上述代码片段中，我们可以看出两点：  </p>
<ol>
<li>Java编译，如果没有指定编码，则会使用Unicode，具体是UTF-8编码来存储到.class中；</li>
<li>Java的String对象中存储的char[]都是用Unicode，具体是UTF-8来存储的。</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
